<HTML>
<HEAD>
<TITLE>
Цепочечные команды
</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF" Background="../../fon.jpg">
<!базовый размер символов (для всего документа>
<!тело html-документа>
<!C-HR SIZE=5 WIDTH=60%>
<A NAME="Цепочечные">
</A>
<H2>
<FONT SIZE="+0">
Цепочечные команды
</FONT>
</H2>
<FONT SIZE="+0">
Эти команды также называют командами 
<I>
обработки строк символов
</I>
.
Названия почти синонимичны.
</FONT>
<BR>
<FONT SIZE="+0">
Отличие в том, что под 
<I>
строкой символов
</I>
 здесь
понимается последовательность байт, а 
<I>
цепочка
</I>
 — это более общее
название для случаев, когда элементы последовательности имеют размер больше
байта — слово или двойное слово.
</FONT>
<BR>
<FONT SIZE="+0">
Таким образом, цепочечные команды позволяют проводить
действия над блоками памяти, представляющими собой последовательности элементов
следующего размера:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
8 бит — байт;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
16 бит — слово;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
32 бита — двойное слово.
</FONT>
</LI>
</UL>
<P>
<FONT SIZE="+0">
Содержимое этих блоков для микропроцессора не имеет никакого
значения. Это могут быть символы, числа и все что угодно. Главное, чтобы
размерность элементов совпадала с одной из перечисленных и эти элементы
находились в соседних ячейках памяти.
</FONT>
<P>
<FONT SIZE="+0">
Всего в системе команд микропроцессора имеется семь 
<I>
операций-примитивов
</I>
обработки цепочек.
</FONT>
<BR>
<FONT SIZE="+0">
Каждая из них реализуется в микропроцессоре тремя командами,
в свою очередь, каждая из этих команд работает с соответствующим размером
элемента — байтом, словом или двойным словом.
</FONT>
<BR>
<FONT SIZE="+0">
Особенность всех цепочечных команд в том, что они, кроме
обработки текущего элемента цепочки, осуществляют еще и 
<B>
автоматическое
продвижение
</B>
 к следующему элементу данной цепочки.
</FONT>
<P>
<FONT SIZE="+0">
Перечислим операции-примитивы и команды, с помощью которых
они реализуются, а затем подробно их рассмотрим:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
<I>
пересылка цепочки
</I>
:
</FONT>
</LI>
<UL>
<FONT SIZE="+0">
<B>
<A HREF="#movs">
movs
</A>
</B>
<B>
адрес_приемника,адрес_источника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#movs">
movsb
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#movs">
movsw
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#movs">
movsd
</A>
</B>
</FONT>
</UL>
<LI>
<FONT SIZE="+0">
<I>
сравнение цепочек
</I>
:
</FONT>
</LI>
<UL>
<FONT SIZE="+0">
<B>
<A HREF="#cmps">
cmps
</A>
</B>
<B>
адрес_приемника,адрес_источника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#cmps">
cmpsb
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#cmps">
cmpsw
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#cmps">
cmpsd
</A>
</B>
</FONT>
</UL>
<LI>
<FONT SIZE="+0">
<I>
сканирование цепочки
</I>
:
</FONT>
</LI>
<UL>
<FONT SIZE="+0">
<B>
<A HREF="#scas">
scas
</A>
</B>
<B>
адрес_приемника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#scas">
scasb
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#scas">
scasw
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#scas">
scasd
</A>
</B>
</FONT>
</UL>
<LI>
<FONT SIZE="+0">
<I>
загрузка элемента из цепочки
</I>
:
</FONT>
</LI>
<UL>
<FONT SIZE="+0">
<B>
<A HREF="#lods">
lods
</A>
</B>
<B>
адрес_источника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#lods">
lodsb
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#lods">
lodsw
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#lods">
lodsd
</A>
</B>
</FONT>
</UL>
<LI>
<FONT SIZE="+0">
<I>
сохранение элемента в цепочке
</I>
:
</FONT>
</LI>
<UL>
<FONT SIZE="+0">
<B>
<A HREF="#stos">
stos
</A>
</B>
<B>
адрес_приемника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#stos">
stosb
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#stos">
stosw
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#stos">
stosd
</A>
</B>
</FONT>
</UL>
<LI>
<FONT SIZE="+0">
<I>
получение элементов цепочки из порта ввода-вывода
</I>
:
</FONT>
</LI>
<UL>
<FONT SIZE="+0">
<B>
<A HREF="#ins">
ins
</A>
</B>
<B>
адрес_приемника,номер_порта
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#ins">
insb
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#ins">
insw
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#ins">
insd
</A>
</B>
</FONT>
</UL>
<LI>
<FONT SIZE="+0">
<I>
вывод элементов цепочки в порт ввода-вывода
</I>
:
</FONT>
</LI>
<UL>
<FONT SIZE="+0">
<B>
<A HREF="#outs">
outs
</A>
</B>
<B>
номер_порта,адрес_источника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#outs">
outsb
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#outs">
outsw
</A>
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#outs">
outsd
</A>
</B>
</FONT>
</UL>
</UL>
<FONT SIZE="+0">
Логически к этим командам нужно отнести и так называемые
<B>
префиксы повторения
</B>
. Вспомните 
<A HREF="../Занятие_6/Зан_06.htm#ФорматМашиннойКоманды">
формат
машинной команды
</A>
 и его первые необязательные байты префиксов. Один
из возможных типов префиксов — это 
<I>
префиксы повторения
</I>
. Они предназначены
для использования цепочечными командами.
</FONT>
<P>
<FONT SIZE="+0">
Префиксы повторения имеют свои мнемонические обозначения:
</FONT>
<BLOCKQUOTE>
<FONT SIZE="+0">
<B>
rep
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
repe
</B>
 или 
<B>
repz
</B>
</FONT>
<BR>
<FONT SIZE="+0">
<B>
repne
</B>
 или 
<B>
repnz
</B>
</FONT>
</BLOCKQUOTE>
<P>
<FONT SIZE="+0">
Эти префиксы повторения указываются перед нужной цепочечной
командой в поле метки.
</FONT>
<BR>
<FONT SIZE="+0">
Цепочечная команда без префикса выполняется один раз.
Размещение префикса перед цепочечной командой заставляет ее выполняться
в цикле.
</FONT>
<P>
<FONT SIZE="+0">
Отличия приведенных префиксов в том, на каком основании
принимается решение о циклическом выполнении цепочечной команды: 
<I>
по
состоянию регистра ecx/cx или по флагу нуля zf
</I>
:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
префикс повторения 
<B>
rep
</B>
 (REPeat). Этот префикс используется
с командами, реализующими операции-примитивы пересылки и сохранения элементов
цепочек — соответственно, 
<B>
movs
</B>
 и 
<B>
stos
</B>
.
</FONT>
</LI>
<BR>
<FONT SIZE="+0">
Префикс 
<B>
rep
</B>
 заставляет данные команды выполняться,
пока 
<I>
содержимое в ecx/cx не станет равным 0
</I>
.
</FONT>
<BR>
<FONT SIZE="+0">
При этом цепочечная команда, перед которой стоит префикс,
<I>
автоматически уменьшает содержимое ecx/cx на единицу
</I>
. Та же команда,
но без префикса, этого не делает;
</FONT>
<LI>
<FONT SIZE="+0">
префиксы повторения 
<B>
repe
</B>
 или 
<B>
repz
</B>
 (REPeat while
Equal or Zero). Эти префиксы являются абсолютными синонимами.
</FONT>
</LI>
<BR>
<FONT SIZE="+0">
Они заставляют цепочечную команду выполняться до тех
пор, пока 
<I>
содержимое ecx/cx не равно нулю или флаг zf равен 1
</I>
.
</FONT>
<BR>
<FONT SIZE="+0">
Как только одно из этих условий нарушается, управление
передается следующей команде программы. Благодаря возможности анализа флага
zf, наиболее эффективно эти префиксы можно использовать с командами cmps
и scas для поиска отличающихся элементов цепочек.
</FONT>
<LI>
<FONT SIZE="+0">
префиксы повторения 
<B>
repne
</B>
 или 
<B>
repnz
</B>
 (REPeat
while Not Equal or Zero). Эти префиксы также являются абсолютными синонимами.
Их действие на цепочечную команду несколько отличается от действий префиксов
repe/repz. Префиксы repne/repnz заставляют цепочечную команду циклически
выполняться до тех пор, пока 
<I>
содержимое ecx/cx не равно нулю или флаг
zf равен нулю
</I>
.
</FONT>
</LI>
<BR>
<FONT SIZE="+0">
При невыполнении одного из этих условий работа команды
прекращается.
</FONT>
<BR>
<FONT SIZE="+0">
Данные префиксы также можно использовать с командами
cmps и scas, но для поиска совпадающих элементов цепочек.
</FONT>
</UL>
<FONT SIZE="+0">
Следующий важный момент, связанный с цепочечными командами,
заключается в 
<I>
особенностях формирования физического адреса
</I>
 операндов
адрес_источника и адрес_приемника.
</FONT>
<BR>
<FONT SIZE="+0">
<B>
Цепочка-источник
</B>
, адресуемая операндом 
<I>
адрес_источника
</I>
,
<U>
может
</U>
 находиться в текущем сегменте данных, определяемом регистром
<B>
ds
</B>
.
</FONT>
<BR>
<FONT SIZE="+0">
<B>
Цепочка-приемник
</B>
, адресуемая операндом 
<I>
адрес_приемника
</I>
,
<U>
должна
</U>
 быть в дополнительном сегменте данных, адресуемом сегментным
регистром 
<B>
es
</B>
.
</FONT>
<BR>
<FONT SIZE="+0">
Важно отметить, что допускается 
<I>
замена
</I>
 (с помощью
префикса замены сегмента) только регистра 
<B>
ds
</B>
, регистр es подменять
нельзя.
</FONT>
<BR>
<FONT SIZE="+0">
Вторые части адресов - 
<I>
смещения цепочек
</I>
 — также
находятся в строго определенных местах.
</FONT>
<BR>
<FONT SIZE="+0">
Для 
<B>
цепочки-источника
</B>
 это регистр 
<B>
esi/si
</B>
(Source Index register — индексный регистр источника).
</FONT>
<BR>
<FONT SIZE="+0">
Для 
<B>
цепочки-получателя
</B>
 это регистр 
<B>
edi/di
</B>
(Destination Index register - индексный регистр приемника).
</FONT>
<BR>
<FONT SIZE="+0">
Таким образом, полные физические адреса для операндов
цепочечных команд следующие:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
адрес_источника — пара 
<B>
ds:esi/si
</B>
;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
адрес_приемника — пара 
<B>
es:edi/di
</B>
.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Вы, наверное обратили внимание на то, что все семь групп
команд, реализующих цепочечные операции-примитивы, имеют похожий по структуре
набор команд.
</FONT>
<BR>
<FONT SIZE="+0">
В каждом из этих наборов присутствует одна команда с
явным указанием операндов и три команды, не имеющие операндов.
</FONT>
<BR>
<FONT SIZE="+0">
На самом деле, набор команд микропроцессора имеет соответствующие
машинные команды только для цепочечных команд ассемблера без операндов.
Команды с операндами транслятор ассемблера использует только для определения
типов операндов.
</FONT>
<BR>
<FONT SIZE="+0">
После того как выяснен тип элементов цепочек по их описанию
в памяти, генерируется одна из трех машинных команд для каждой из цепочечных
операций. По этой причине все регистры, содержащие адреса цепочек, должны
быть инициализированы заранее, в том числе и для команд, допускающих явное
указание операндов.
</FONT>
<BR>
<FONT SIZE="+0">
В силу того, что цепочки адресуются однозначно, нет особого
смысла применять команды с операндами. Главное, что вы должны запомнить,
— 
<I>
правильная загрузка регистров указателями обязательно требуется до
выдачи любой цепочечной команды
</I>
.
</FONT>
<P>
<FONT SIZE="+0">
Последний важный момент, касающийся всех цепочечных команд,
— это 
<I>
направление обработки цепочки
</I>
. Есть две возможности:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
от начала цепочки к ее концу, то есть в направлении возрастания
адресов;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
от конца цепочки к началу, то есть в направлении убывания
адресов.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Как мы увидим ниже, цепочечные команды сами выполняют модификацию
регистров, адресующих операнды, обеспечивая тем самым автоматическое продвижение
по цепочке. Количество байт, на которые эта модификация осуществляется,
определяется кодом команды. А вот знак этой модификации определяется значением
флага направления 
<B>
df
</B>
 (Direction Flag) в регистре eflags/flags:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
если 
<B>
df = 0
</B>
, то значение индексных регистров esi/si
и edi/di будет автоматически увеличиваться (операция инкремента) цепочечными
командами, то есть обработка будет осуществляться в направлении возрастания
адресов;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
если 
<B>
df = 1
</B>
, то значение индексных регистров esi/si
и edi/di будет автоматически уменьшаться (операция декремента) цепочечными
командами, то есть обработка будет идти в направлении убывания адресов.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Состоянием флага 
<B>
df
</B>
 можно управлять с помощью двух
команд, не имеющих операндов:
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#cld">
cld
</A>
</B>
(Clear Direction Flag) — очистить флаг направления. Команда сбрасывает
флаг направления df в 0.
</FONT>
<BR>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#std">
std
</A>
</B>
(Set Direction Flag) — установить флаг направления. Команда устанавливает
флаг направления df в 1.
</FONT>
<P>
<FONT SIZE="+0">
Это вся информация, касающаяся общих свойств цепочечных
команд. Далее мы более подробно рассмотрим каждую операцию-примитив и команды,
которые ее реализуют. При этом более подробно мы будем рассматривать одну
команду в каждой группе цепочечных команд — команду с операндами. Это будет
делаться из тех соображений, что это более общая команда в смысле ограничений,
накладываемых на типы операндов.&nbsp;
</FONT>
<A NAME="movs">
</A>
<H3>
<FONT SIZE="+0">
Операция пересылки цепочек
</FONT>
</H3>
<FONT SIZE="+0">
Команды, реализующие эту операцию-примитив, производят копирование
элементов из одной области памяти (цепочки) в другую. Размер элемента определяется
применяемой командой.
</FONT>
<P>
<FONT SIZE="+0">
Система команд TASM предоставляет программисту четыре
команды, работающие с разными размерами элементов цепочки:
</FONT>
<BLOCKQUOTE>
<FONT SIZE="+0">
<B>
movs адрес_приемника,адрес_источника
</B>
 (MOVe
String) — переслать цепочку;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
movsb
</B>
 (MOVe String Byte) — переслать цепочку байт;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
movsw
</B>
 (MOVe String Word) — переслать цепочку слов;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
movsd
</B>
 (MOVe String Double word) — переслать цепочку
двойных слов.
</FONT>
</BLOCKQUOTE>
<H4>
<FONT SIZE="+0">
Команда movs:
</FONT>
</H4>
<FONT SIZE="+0">
<B>
<A HREF="../../Text/Command.htm#movs">
movs
</A>
</B>
<B>
адрес_приемника,адрес_источника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
Команда копирует байт, слово или двойное слово из цепочки,
адресуемой операндом адрес_источника, в цепочку, адресуемую операндом адрес_приемника.
</FONT>
<BR>
<FONT SIZE="+0">
Размер пересылаемых элементов ассемблер определяет, исходя
из атрибутов идентификаторов, указывающих на области памяти приемника и
источника. К примеру, если эти идентификаторы были определены директивой
db, то пересылаться будут байты, если идентификаторы были определены с
помощью директивы dd, то пересылке подлежат 32-битовые элементы, то есть
двойные слова.
</FONT>
<BR>
<FONT SIZE="+0">
Ранее уже было отмечено, что для цепочечных команд с
операндами, к которым относится и команда пересылки 
<B>
movs адрес_приемника,адрес_источника
</B>
,
не существует машинного аналога.
</FONT>
<BR>
<FONT SIZE="+0">
При трансляции в зависимости от типа операндов транслятор
преобразует ее в одну из трех машинных команд:
</FONT>
<BR>
<FONT SIZE="+0">
<B>
movsb, movsw 
</B>
или
<B>
 movsd
</B>
.
</FONT>
<P>
<FONT SIZE="+0">
Сама по себе команда movs пересылает только один элемент,
исходя из его типа, и модифицирует значения регистров esi/si и edi/di.
Если перед командой написать префикс 
<B>
rep
</B>
, то одной командой можно
переслать до 64 Кбайт данных (если размер адреса в сегменте 16 бит — use16)
или до 4 Гбайт данных (если размер адреса в сегменте 32 бит - use32).
</FONT>
<BR>
<FONT SIZE="+0">
Число пересылаемых элементов должно быть загружено в
<I>
счетчик
</I>
 — регистр 
<B>
cx
</B>
 (use16) или 
<B>
ecx
</B>
 (use32).
</FONT>
<P>
<FONT SIZE="+0">
Перечислим набор действий, которые нужно выполнить в программе
для того, чтобы выполнить пересылку последовательности элементов из одной
области памяти в другую с помощью команды movs.
</FONT>
<BR>
<FONT SIZE="+0">
В общем случае этот набор действий можно рассматривать
как типовой для выполнения любой цепочечной команды:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
Установить значение флага df в зависимости от того, в каком
направлении будут обрабатываться элементы цепочки — в направлении возрастания
или убывания адресов.
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
Загрузить указатели на адреса цепочек в памяти в пары регистров
ds:(e)si и es: (e)di.
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
Загрузить в регистр ecx/cx количество элементов, подлежащих
обработке.
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
Выдать команду movs с префиксом rep.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
На примере листинга 1 рассмотрим, как эти действия реализуются
программно. В этой программе производится пересылка символов из одной строки
в другую. Строки находятся в одном сегменте памяти. Для пересылки используется
команда-примитив movs с префиксом повторения rep.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
&nbsp;
Листинг 1 Пересылка строк командой movs
;prg_11_1.asm
MASM
MODEL&nbsp;&nbsp; small
STACK&nbsp;&nbsp; 256
.data
source&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Тестируемая строка','$'
;строка-источник
dest&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19 DUP (' ')&nbsp;&nbsp;&nbsp; ;строка-приёмник
.code
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; ds:@data,es:@data
main:&nbsp;&nbsp; ;точка входа в программу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка сегментных регистров
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax&nbsp;&nbsp; ;настройка регистров DS и ES
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;на адрес сегмента данных
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; ;сброс флага DF — обработка строки от начала к концу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в si смещения строки-источника
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,dest ;загрузка в DS смещения строки-приёмника
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,20&nbsp;&nbsp; ;для префикса rep — счетчик повторений (длина строки)
rep&nbsp;&nbsp;&nbsp;&nbsp; movs&nbsp;&nbsp;&nbsp; dest,source&nbsp;&nbsp;&nbsp;&nbsp; ;пересылка строки
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,dest
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h&nbsp; ;вывод на экран строки-приёмника
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
exit:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
end&nbsp;&nbsp;&nbsp;&nbsp; main
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<A NAME="cmps">
</A>
<H3>
<FONT SIZE="+0">
Операция сравнения цепочек
</FONT>
</H3>
<FONT SIZE="+0">
Команды, реализующие эту операцию-примитив, производят сравнение
элементов цепочки-источника с элементами цепочки-приемника. Здесь ситуация
с набором команд и методами работы с ними аналогична операции-примитиву
пересылки цепочек.
</FONT>
<BR>
<FONT SIZE="+0">
TASM предоставляет программисту четыре команды сравнения
цепочек, работающие с разными размерами элементов цепочки:
</FONT>
<BLOCKQUOTE>
<FONT SIZE="+0">
<B>
cmps адрес_приемника,адрес_источника
</B>
(CoMPare
String) — сравнить строки;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
cmpsb
</B>
 (CoMPare String Byte) — сравнить строку
байт;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
cmpsw
</B>
 (CoMPare String Word) — сравнить строку
слов;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
cmpsd
</B>
 (CoMPare String Double word) — сравнить
строку двойных слов.
</FONT>
</BLOCKQUOTE>
<H4>
<FONT SIZE="+0">
Команда cmps
</FONT>
</H4>
<FONT SIZE="+0">
Синтаксис команды cmps:
</FONT>
<BR>
<FONT SIZE="+0">
<B>
cmps адрес_приемника,адрес_источника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
Здесь:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
<I>
адрес_источника
</I>
 определяет 
<B>
цепочку-источник
</B>
в сегменте данных. Адрес цепочки должен быть заранее загружен в пару 
<B>
ds:esi/si
</B>
;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
адрес_приемника
</I>
 определяет 
<B>
цепочку-приемник
</B>
.
Цепочка должна находиться в дополнительном сегменте, и ее адрес должен
быть заранее загружен в пару 
<B>
es:edi/di
</B>
.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Алгоритм работы команды cmps заключается в последовательном
выполнении вычитания 
<U>
(элемент цепочки-источника — элемент цепочки-получателя)
</U>
над очередными элементами обеих цепочек.
</FONT>
<BR>
<FONT SIZE="+0">
Принцип выполнения вычитания командой cmps аналогичен
команде сравнения cmp. Она, так же, как и cmp, производит вычитание элементов,
не записывая при этом результата, и устанавливает флаги zf, sf и of.
</FONT>
<BR>
<FONT SIZE="+0">
После выполнения вычитания очередных элементов цепочек
командой cmps, индексные регистры esi/si и edi/di 
<I>
автоматически изменяются
в соответствии со значением флага df на значение, равное размеру элемента
сравниваемых цепочек
</I>
.
</FONT>
<BR>
<FONT SIZE="+0">
Чтобы заставить команду cmps выполняться несколько раз,
то есть производить последовательное сравнение элементов цепочек, необходимо
перед командой cmps определить префикс повторения.
</FONT>
<BR>
<FONT SIZE="+0">
С командой cmps можно использовать префикс повторения
<B>
repe/repz
</B>
 или 
<B>
repne/repnz
</B>
:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
repe или repz — если необходимо организовать сравнение до
тех пор, пока не будет выполнено одно из двух условий:
</FONT>
</LI>
<UL>
<LI>
<FONT SIZE="+0">
достигнут конец цепочки (содержимое ecx/cx равно нулю);
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
в цепочках встретились разные элементы (флаг zf стал равен
нулю);
</FONT>
</LI>
</UL>
<LI>
<FONT SIZE="+0">
repne или repnz — если нужно проводить сравнение до тех пор,
пока:
</FONT>
</LI>
<UL>
<LI>
<FONT SIZE="+0">
не будет достигнут конец цепочки (содержимое ecx/cx равно
нулю);
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
в цепочках встретились одинаковые элементы (флаг zf стал
равен единице).
</FONT>
</LI>
</UL>
</UL>
<FONT SIZE="+0">
Таким образом, выбрав подходящий префикс, удобно использовать
команду cmps для поиска одинаковых или различающихся элементов цепочек.
</FONT>
<BR>
<FONT SIZE="+0">
Выбор префикса определяется причиной, которая приводит
к выходу из цикла. Таких причин может быть две для каждого из префиксов.
Для определения конкретной причины наиболее подходящим является способ,
использующий команду условного перехода 
<B>
jcxz
</B>
. Ее работа заключается
в анализе содержимого регистра ecx/cx, и если оно равно нулю, то управление
передается на метку, указанную в качестве операнда jcxz. Так как в регистре
ecx/cx содержится счетчик повторений для цепочечной команды, имеющей любой
из префиксов повторения, то, анализируя ecx/cx, можно определить причину
выхода из зацикливания цепочечной команды. Если значение в ecx/cx 
<I>
не
равно нулю
</I>
, то это означает, что выход произошел по причине совпадения
либо несовпадения очередных элементов цепочек.
</FONT>
<BR>
<FONT SIZE="+0">
Существует возможность еще больше конкретизировать информацию
о причине, приведшей к окончанию операции сравнения. Сделать это можно
с помощью команд условной передачи управления (табл. 1 и 2).
</FONT>
<P>
<FONT SIZE="+0">
<B>
Таблица 1. 
</B>
Сочетание команд условной передачи управления
с результатами команды cmps (для чисел со знаком)
</FONT>
<P>
<CENTER>
<TABLE BORDER="5" RULES="ALL" VALIGN="MIDDLE">
<TR>
<TD ALIGN="CENTER">
Причина прекращения операции сравнения
</TD>
<TD>
Команда условного перехода, реализующая переход по этой причине
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
</TD>
<TD ALIGN="CENTER">
jg
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
операнд_источник = операнд_приемник
</TD>
<TD ALIGN="CENTER">
je
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
</TD>
<TD ALIGN="CENTER">
jne
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
операнд_источник &lt; операнд_приемник
</TD>
<TD ALIGN="CENTER">
jl
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
операнд_источник &lt;= операнд_приемник
</TD>
<TD ALIGN="CENTER">
jle
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
</TD>
<TD ALIGN="CENTER">
jge
</TD>
</TR>
</TABLE>
</CENTER>
<P>
<B>
<FONT SIZE="+0">
Таблица 2.
</FONT>
</B>
<FONT SIZE="+0">
 Сочетание команд условной
передачи управления с результатами команды cmps (для чисел без знака)
</FONT>
<P>
<CENTER>
<TABLE BORDER="5" RULES="ALL" VALIGN="MIDDLE">
<TR>
<TD ALIGN="CENTER">
Причина прекращения операции сравнения
</TD>
<TD>
Команда условного перехода, реализующая переход по этой причине
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
</TD>
<TD ALIGN="CENTER">
ja
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
операнд_источник = операнд_приемник
</TD>
<TD ALIGN="CENTER">
je
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
</TD>
<TD ALIGN="CENTER">
jne
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
операнд_источник &lt; операнд_приемник
</TD>
<TD ALIGN="CENTER">
jb
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
операнд_источник &lt;= операнд_приемник
</TD>
<TD ALIGN="CENTER">
jbe
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
</TD>
<TD ALIGN="CENTER">
jae
</TD>
</TR>
</TABLE>
</CENTER>
<P>
<P>
<FONT SIZE="+0">
Как определить местоположение очередных совпавших или не
совпавших элементов в цепочках?
</FONT>
<P>
<FONT SIZE="+0">
Вспомните, что после каждой итерации цепочечная команда
автоматически осуществляет инкремент/декремент значения адреса в соответствующих
индексных регистрах. Поэтому после выхода из цикла в этих регистрах будут
находиться адреса элементов, находящихся в цепочке 
<B>
после (!) элементов
</B>
,
которые послужили причиной выхода из цикла.
</FONT>
<BR>
<FONT SIZE="+0">
Для получения истинного адреса этих элементов необходимо
скорректировать содержимое индексных регистров, увеличив либо уменьшив
значение в них на длину элемента цепочки.
</FONT>
<BR>
<FONT SIZE="+0">
В качестве примера рассмотрим программу из листинга 2,
которая сравнивает две строки, находящиеся в одном сегменте. Используется
команда cmps. Префикс повторения - repe.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE="+0">
Программа достаточно прозрачна, только два момента, на мой
взгляд, требуют пояснения:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
<I>
во-первых
</I>
, строки 42 и 43, в которых мы скорректировали
адреса очередных элементов для получения адресов несовпавших элементов.
Вы должны понимать, что если сравниваются цепочки с элементами слов или
двойных слов, то корректировать содержимое esi/si и edi/di нужно на 2 и
4 байта соответственно;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
во-вторых
</I>
, строки 47–49. Смысл их в том, что для просмотра
оставшейся части строк необходимо установить указатели на следующие элементы
строк за последними несовпавшими. После этого можно повторить весь процесс
просмотра и обработки несовпавших элементов в оставшихся частях строк.&nbsp;
</FONT>
<A NAME="scas">
</A>
</LI>
<H3>
<FONT SIZE="+0">
Операция сканирования цепочек
</FONT>
</H3>
<FONT SIZE="+0">
Команды, реализующие эту операцию-примитив, производят поиск
некоторого значения в области памяти. Логически эта область памяти рассматривается
как последовательность (цепочка) элементов фиксированной длины размером
8, 16 или 32 бит.
</FONT>
<BR>
<FONT SIZE="+0">
Искомое значение предварительно должно быть помещено
в регистр 
<B>
al/ax/eax
</B>
. Выбор конкретного регистра из этих трех должен
быть согласован с размером элементов цепочки, в которой осуществляется
поиск.
</FONT>
<P>
<FONT SIZE="+0">
Система команд микропроцессора предоставляет программисту
четыре команды сканирования цепочки.
</FONT>
<BR>
<FONT SIZE="+0">
Выбор конкретной команды определяется размером элемента:
</FONT>
<UL>
<FONT SIZE="+0">
<B>
scas адрес_приемника
</B>
 (SCAning String) — сканировать
цепочку;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
scasb
</B>
 (SCAning String Byte) — сканировать цепочку
байт;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
scasw
</B>
 (SCAning String Word) — сканировать цепочку
слов;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
scasd
</B>
 (SCAning String Double Word) — сканировать
цепочку двойных слов.
</FONT>
</UL>
<H4>
<FONT SIZE="+0">
Команда scas
</FONT>
</H4>
<FONT SIZE="+0">
<B>
scas адрес_приемника
</B>
</FONT>
<BR>
<FONT SIZE="+0">
Команда имеет один операнд, обозначающий местонахождение
цепочки в дополнительном сегменте (адрес цепочки должен быть заранее сформирован
в 
<B>
es:edi/di
</B>
).
</FONT>
<BR>
<FONT SIZE="+0">
Транслятор анализирует тип идентификатора 
<I>
адрес_приемника
</I>
,
который обозначает цепочку в сегменте данных, и формирует одну из трех
машинных команд 
<B>
scasb, scasw или scasd
</B>
.
</FONT>
<BR>
<FONT SIZE="+0">
Условие поиска для каждой из этих трех команд находится
в строго определенном месте. Так, если цепочка описана с помощью директивы
db, то искомый элемент должен быть байтом и находиться в al, а сканирование
цепочки осуществляется командой scasb; если цепочка описана с помощью директивы
dw, то это — слово в ax, и поиск ведется командой scasw; если цепочка описана
с помощью директивы dd, то это — двойное слово в eax, и поиск ведется командой
scasd. Принцип поиска тот же, что и в команде сравнения cmps, то есть последовательное
выполнение вычитания
</FONT>
<BR>
<FONT SIZE="+0">
<U>
(содержимое_регистра_аккумулятора - содержимое_очередного_элемента_цепочки)
</U>
.
</FONT>
<BR>
<FONT SIZE="+0">
В зависимости от результатов вычитания производится установка
флагов, при этом сами операнды не изменяются.
</FONT>
<BR>
<FONT SIZE="+0">
Так же, как и в случае команды cmps, с командой scas
удобно использовать префиксы 
<B>
repe/repz
</B>
 или 
<B>
repne/repnz
</B>
:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
<B>
repe
</B>
 или 
<B>
repz
</B>
 — если нужно организовать поиск
до тех пор, пока не будет выполнено одно из двух условий:
</FONT>
</LI>
<UL>
<LI>
<FONT SIZE="+0">
достигнут конец цепочки (содержимое ecx/cx равно 0);
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
в цепочке встретился элемент, отличный от элемента в регистре
al/ax/eax;
</FONT>
</LI>
</UL>
<LI>
<FONT SIZE="+0">
<B>
repne
</B>
 или 
<B>
repnz
</B>
 — если нужно организовать поиск
до тех пор, пока не будет выполнено одно из двух условий:
</FONT>
</LI>
<UL>
<LI>
<FONT SIZE="+0">
достигнут конец цепочки (содержимое ecx/cx равно 0);
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
в цепочке встретился элемент, совпадающий с элементом в регистре
al/ax/eax.
</FONT>
</LI>
</UL>
</UL>
<FONT SIZE="+0">
Таким образом, команда scas с префиксом repe/repz позволяет
найти элемент цепочки, 
<I>
отличающийся
</I>
 по значению от заданного в аккумуляторе.
</FONT>
<BR>
<FONT SIZE="+0">
Команда scas с префиксом 
<I>
repne/repnz
</I>
 позволяет
найти элемент цепочки, совпадающий по значению с элементом в аккумуляторе.
</FONT>
<P>
<FONT SIZE="+0">
В качестве примера рассмотрим листинг 3, который производит
поиск символа в строке.
</FONT>
<BR>
<FONT SIZE="+0">
В программе используется команда-примитив scas.
</FONT>
<BR>
<FONT SIZE="+0">
Символ задается явно (строка 20).
</FONT>
<BR>
<FONT SIZE="+0">
Префикс повторения — repne.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<A NAME="lods">
</A>
<H3>
<FONT SIZE="+0">
Загрузка элемента цепочки в аккумулятор
</FONT>
</H3>
<FONT SIZE="+0">
Эта операция-примитив позволяет извлечь элемент цепочки и
поместить его в регистр-аккумулятор al, ax или eax. Эту операцию удобно
использовать вместе с поиском (сканированием) с тем, чтобы, найдя нужный
элемент, извлечь его (например, для изменения).
</FONT>
<BR>
<FONT SIZE="+0">
Возможный размер извлекаемого элемента определяется применяемой
командой.
</FONT>
<P>
<FONT SIZE="+0">
Программист может использовать четыре команды загрузки
элемента цепочки в аккумулятор, работающие с элементами разного размера:
</FONT>
<UL>
<FONT SIZE="+0">
<B>
lods адрес_источника 
</B>
(LOaD String) — загрузить
элемент из цепочки в регистр-аккумулятор al/ax/eax;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
lodsb
</B>
 (LOaD String Byte) — загрузить байт из цепочки
в регистр al;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
lodsw
</B>
 (LOaD String Word) — загрузить слово из
цепочки в регистр ax;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
lodsd
</B>
 (LOaD String Double Word) — загрузить двойное
слово из цепочки в регистр eax.
</FONT>
</UL>
<FONT SIZE="+0">
Рассмотрим работу этих команд на примере lods.
</FONT>
<H4>
<FONT SIZE="+0">
Команда lods
</FONT>
</H4>
<FONT SIZE="+0">
<B>
lods адрес_источника
</B>
 (LOaD String) — загрузить элемент
из цепочки в аккумулятор 
<B>
al/ax/eax
</B>
.
</FONT>
<BR>
<FONT SIZE="+0">
Команда имеет один операнд, обозначающий строку в основном
сегменте данных. Работа команды заключается в том, чтобы извлечь элемент
из цепочки по адресу, соответствующему содержимому пары регистров 
<B>
ds:esi/si
</B>
,
и поместить его в регистр 
<B>
eax/ax/al
</B>
. При этом содержимое esi/si
подвергается инкременту или декременту (в зависимости от состояния флага
df) на значение, равное размеру элемента.
</FONT>
<BR>
<FONT SIZE="+0">
Эту команду удобно использовать после команды 
<B>
scas
</B>
,
локализующей местоположение искомого элемента в цепочке.
</FONT>
<BR>
<FONT SIZE="+0">
Префикс повторения в этой команде может и не понадобиться
— все зависит от логики программы.
</FONT>
<P>
<FONT SIZE="+0">
В качестве примера рассмотрим листинг 4. Программа сравнивает
командой cmps две цепочки байт в памяти string1 и string2 и помещает первый
несовпавший байт из string2 в регистр al. Для загрузки этого байта в регистр-аккумулятор
al используется команда lods. Префикса повторения в команде lods нет, так
как он попросту не нужен.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<A NAME="stos">
</A>
<H3>
<FONT SIZE="+0">
Перенос элемента из аккумулятора в цепочку
</FONT>
</H3>
<FONT SIZE="+0">
Эта операция-примитив позволяет произвести действие, обратное
команде lods, то есть сохранить значение из регистра-аккумулятора в элементе
цепочки.
</FONT>
<BR>
<FONT SIZE="+0">
Эту операцию удобно использовать вместе с операцией поиска
(сканирования) scans и загрузки lods, с тем, чтобы, 
<I>
найдя нужный элемент,
извлечь его в регистр и записать на его место новое значение
</I>
.
</FONT>
<BR>
<FONT SIZE="+0">
Команды, поддерживающие эту операцию-примитив, могут
работать с элементами размером 8, 16 или 32 бит.
</FONT>
<BR>
<FONT SIZE="+0">
TASM предоставляет программисту четыре команды сохранения
элемента цепочки из регистра-аккумулятора, работающие с элементами разного
размера:
</FONT>
<UL>
<FONT SIZE="+0">
<B>
stos адрес_приемника
</B>
 (STOre String) — сохранить
элемент из регистра-аккумулятора al/ax/eax в цепочке;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
stosb
</B>
 (STOre String Byte) — сохранить байт из
регистра al в цепочке;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
stosw
</B>
 (STOre String Word) — сохранить слово из
регистра ax в цепочке;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
stosd
</B>
 (STOre String Double Word) - сохранить двойное
слово из регистра eax в цепочке.
</FONT>
</UL>
<H4>
<FONT SIZE="+0">
Команда stos
</FONT>
</H4>
<FONT SIZE="+0">
<B>
stos адрес_приемника
</B>
 (STOrage String) — сохранить
элемент из регистра-аккумулятора al/ax/eax в цепочке.
</FONT>
<P>
<FONT SIZE="+0">
Команда имеет один операнд 
<I>
адрес_приемника
</I>
, адресующий
цепочку в дополнительном сегменте данных.
</FONT>
<BR>
<FONT SIZE="+0">
Работа команды заключается в том, что она пересылает
элемент из аккумулятора (регистра 
<B>
eax/ax/al
</B>
) в элемент цепочки по
адресу, соответствующему содержимому пары регистров 
<B>
es:edi/di
</B>
. При
этом содержимое edi/di подвергаются инкременту или декременту (в зависимости
от состояния флага df) на значение, равное размеру элемента цепочки.
</FONT>
<BR>
<FONT SIZE="+0">
Префикс повторения в этой команде может и не понадобиться
— все зависит от логики программы. Например, если использовать префикс
повторения rep, то можно применить команду для инициализации области памяти
некоторым фиксированным значением.
</FONT>
<P>
<FONT SIZE="+0">
В качестве примера рассмотрим листинг 5. Программа производит
замену в строке всех символов “а” на другой символ. Символ для замены вводится
с клавиатуры.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
&nbsp;
Листинг 5. Замена командой stos символа в строке на вводимый с клавиатуры
;prg_11_5.asm
MASM
MODEL&nbsp;&nbsp; small
STACK&nbsp;&nbsp; 256
.data
;сообщения
fnd&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Символ найден','$'
nochar&nbsp; db 0ah,0dh,'Символ не найден.','$'
mes1&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Исходная строка:','$'
string&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Поиск символа в этой строке.',0ah,0dh,'$' ;строка для поиска
mes2&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Введите символ, на который следует заменить найденный'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'$'
mes3&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Новая строка: ','$'
.code
&nbsp;assume ds:@data,es:@data привязка ds и es к сегменту данных
main:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;точка входа в программу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка сегментных регистров
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax&nbsp;&nbsp; ;настройка es на ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,mes1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения mes1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,'а'&nbsp; ;символ для поиска-`а`(кириллица)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сброс флага df
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в di смещения string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,29&nbsp;&nbsp; ;для префикса repne — длина строки
;поиск в строке string до тех пор, пока
;символ в al и очередной символ в строке
;не равны: выход - при первом совпадении
cycl:
repne&nbsp;&nbsp; scas string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found&nbsp;&nbsp; ;если элемент найден то переход на found
failed:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;иначе, если не найден, то вывод сообщения nochar
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,nochar
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp; ;переход на выход
found:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,fnd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h ;вывод сообщения об обнаружении символа
;корректируем di для получения значения
;действительной позиции совпавшего элемента
;в строке и регистре al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; di
new_char:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;блок замены символа
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,mes2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения mes2
;ввод символа с клавиатуры
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;в al — введённый символ
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stos&nbsp;&nbsp;&nbsp; string&nbsp; ;сохраним введённый символ
&nbsp;;(из al) в строке string в позиции старого символа
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,mes3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения mes3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h ;вывод сообщения string
;переход на поиск следующего символа ‘а’ в
строке
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;указатель в строке string на следующий,
&nbsp;;после совпавшего, символ
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; cycl&nbsp;&nbsp;&nbsp; ;на продолжение просмотра string
exit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;выход
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
end&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp; ;конец программы
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE="+0">
Следующие две команды появились впервые в системе команд
микропроцессора i386. Они позволяют организовать эффективную передачу данных
между портами ввода-вывода и цепочками в памяти. Следует отметить, что
эти две команды позволяют достичь скорости передачи данных со скоростью
выше той, которую может обеспечить контроллер DMA (Direct Memory Access
— прямой доступ к памяти). Контроллер DMA — это специальная микросхема,
предназначенная для того, чтобы освободить микропроцессор от управления
процессом ввода-вывода больших массивов данных между внешним устройством
(диском) и памятью.&nbsp;
</FONT>
<A NAME="ins">
</A>
<H3>
<FONT SIZE="+0">
Ввод элемента цепочки из порта ввода-вывода
</FONT>
</H3>
<FONT SIZE="+0">
Данная операция позволяет произвести ввод цепочки элементов
из порта ввода-вывода и реализуется командой ins, имеющей следующий формат:
</FONT>
<P>
<FONT SIZE="+0">
<B>
ins адрес_приемника,номер_порта
</B>
 (Input String)
- ввести элементы из порта ввода-вывода в цепочку.
</FONT>
<P>
<FONT SIZE="+0">
Эта команда вводит элемент из порта, номер которого находится
в регистре 
<B>
dx
</B>
, в элемент цепочки, адрес которого определяется операндом
<I>
адрес_приемника
</I>
.
</FONT>
<BR>
<FONT SIZE="+0">
Несмотря на то, что цепочка, в которую вводится элемент,
адресуется указанием этого операнда, ее адрес должен быть явно сформирован
в паре регистров 
<B>
es:edi/di
</B>
.
</FONT>
<BR>
<FONT SIZE="+0">
Размер элементов цепочки должен быть согласован с размерностью
порта — он определяется директивой резервирования памяти, с помощью которой
выделяется память для размещения элементов цепочки.
</FONT>
<BR>
<FONT SIZE="+0">
После пересылки команда ins производит коррекцию содержимого
edi/di на величину, равную размеру элемента, участвовавшего в операции
пересылки. Как обычно, при работе цепочечных команд учитывается состояние
флага df.
</FONT>
<BR>
<FONT SIZE="+0">
Подобно командам, реализующим рассмотренные выше цепочечные
операции-примитивы, транслятор преобразует команду ins в одну из трех машинных
команд без операндов, работающих с цепочками элементов определенного размера:
</FONT>
<UL>
<FONT SIZE="+0">
<B>
insb (INput String Byte)
</B>
 — ввести из порта цепочку
байт;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
insw (INput String Word)
</B>
 — ввести из порта цепочку
слов;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
insd (INput String Double Word)
</B>
 — ввести из порта
цепочку двойных слов.
</FONT>
</UL>
<P>
<FONT SIZE="+0">
К примеру, выведем 10 байт из области памяти pole в порт
5000h.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
&nbsp;
.data
pole&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 dup (‘ ‘)
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;настройка es на ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,5000h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,pole
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,10
rep&nbsp;&nbsp;&nbsp;&nbsp; insb
...
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<A NAME="outs">
</A>
<H4>
<FONT SIZE="+0">
Вывод элемента цепочки в порт ввода-вывода
</FONT>
</H4>
<FONT SIZE="+0">
Данная операция позволяет произвести вывод элементов цепочки
в порт ввода-вывода. Она реализуется командой outs, имеющей следующий формат:
</FONT>
<BR>
<FONT SIZE="+0">
<B>
outs номер_порта,адрес_источника
</B>
 (Output String)
— вывести элементы из цепочки в порт ввода-вывода.
</FONT>
<P>
<FONT SIZE="+0">
Эта команда выводит элемент цепочки в порт, номер которого
находится в регистре 
<B>
dx
</B>
. Адрес элемента цепочки определяется операндом
<I>
адрес_источника
</I>
. Несмотря на то, что цепочка, из которой выводится
элемент, адресуется указанием этого операнда, значение адреса должно быть
явно сформировано в паре регистров 
<B>
ds:esi/si
</B>
.
</FONT>
<BR>
<FONT SIZE="+0">
Размер структурных элементов цепочки должен быть согласован
с размерностью порта. Он определяется директивой резервирования памяти,
с помощью которой выделяется память для размещения элементов цепочки.
</FONT>
<BR>
<FONT SIZE="+0">
После пересылки команда outs производит коррекцию содержимого
esi/si на величину, равную размеру элемента цепочки, участвовавшего в операции
пересылки. При этом, как обычно, учитывается состояние флага df.
</FONT>
<P>
<FONT SIZE="+0">
Подобно команде ins, транслятор преобразует команду outs
в одну из трех машинных команд без операндов, работающих с цепочками элементов
определенного размера:
</FONT>
<UL>
<FONT SIZE="+0">
<B>
outsb
</B>
 (OUTput String Byte) — вывести цепочку байт
в порт ввода-вывода;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
outsw
</B>
 (OUTtput String Word) — вывести цепочку
слов в порт ввода-вывода;
</FONT>
<BR>
<FONT SIZE="+0">
<B>
outsd
</B>
 (OUTput String Double Word) — вывести цепочку
двойных слов в порт ввода- вывода.
</FONT>
</UL>
<P>
<FONT SIZE="+0">
В качестве примера рассмотрим фрагмент программы, которая
выводит последовательность символов в порт ввода-вывода, соответствующего
принтеру (номер 378 (lpt1)).
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
&nbsp;
.data
str_pech&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Текст для печати'
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,378h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,str_pech
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,16
rep&nbsp;&nbsp;&nbsp;&nbsp; outsb
...
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE="+0">
В заключение напомню, что для организации работы с портами
недостаточно знать их номера и назначение. Не менее важно знать и понимать
алгоритм их работы. Эти сведения можно найти в документации на устройство
(но, к сожалению, далеко не всегда).&nbsp;
</FONT>
<HR SIZE="5" WIDTH="80%">
</UL>
</BODY>
<!конец html-документа>
</HTML>
