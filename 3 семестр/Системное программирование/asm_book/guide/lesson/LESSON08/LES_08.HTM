<HTML>
<HEAD>
<TITLE>
Из урока 8
</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF" Background="../../fon.jpg">
<!базовый размер символов (для всего документа>
<!тело html-документа>
<A NAME="ЦелочисленныеАрифметическиеКоманды">
</A>
<HR SIZE="5" WIDTH="60%">
<P>
<FONT SIZE="+0">
Микропроцессор может выполнять целочисленные операции
и операции с плавающей точкой. Для этого в его архитектуре есть два отдельных
блока:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
устройство для выполнения целочисленных операций;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
устройство с плавающей точкой.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Каждое из этих устройств имеет свою систему команд. В принципе,
целочисленное устройство может взять на себя многие функции устройства
с плавающей точкой, но это потребует больших вычислительных затрат. Для
большинства задач, использующих язык ассемблера, достаточно целочисленной
арифметики.
</FONT>
<H2>
<FONT SIZE="+0">
Обзор группы арифметических команд и данных
</FONT>
</H2>
<FONT SIZE="+0">
Целочисленное вычислительное устройство поддерживает чуть больше десятка арифметических команд.
<BR>
На рис. 1 приведена классификация
команд этой группы.
</FONT>
<A NAME="Рис.1">
<P>
<CENTER>
<IMG SRC="Ris8_01.gif">
</A>
<P>
<EM>
<FONT SIZE="+0">
<B>
Рис. 1.
</B>
 Классификация
арифметических команд
</A>
</FONT>
</EM>
</CENTER>
<P>
<FONT SIZE="+0">
Группа арифметических целочисленных команд работает с двумя типами чисел:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
целыми двоичными числами. Числа могут иметь знаковый разряд
или не иметь такового, то есть быть числами со знаком или без знака;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
целыми десятичными числами.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Рассмотрим машинные форматы, в которых хранятся эти типы
данных.
</FONT>
<H3>
<FONT SIZE="+0">
Целые двоичные числа
</FONT>
</H3>
<FONT SIZE="+0">
<I>
Целое двоичное число с фиксированной точкой 
</I>
— это
число, закодированное в двоичной системе счисления.
</FONT>
<P>
<FONT SIZE="+0">
Размерность целого двоичного числа может составлять 8,
16 или 32 бит. Знак двоичного числа определяется тем, как интерпретируется
старший бит в представлении числа. Это 7-й, 15-й или 31-й биты для чисел
соответствующей размерности (см. 
<I>
Типы данных
</I>
). При этом интересно то, что среди арифметических команд есть
всего две команды, которые действительно учитывают этот старший разряд
как знаковый, — это команды целочисленного умножения и деления imul и idiv.
В остальных случаях ответственность за действия со знаковыми числами и,
соответственно, со знаковым разрядом ложится на программиста. К этому вопросу
мы вернемся чуть позже. Диапазон значений двоичного числа зависит от его
размера и трактовки старшего бита либо как старшего значащего бита числа,
либо как бита знака числа (табл. 1).&nbsp;
</FONT>
<A NAME="Таблица_1">
</A>
<P>
<FONT SIZE="+0">
<B>
Таблица 1.
</B>
 Диапазон значений двоичных чисел
</FONT>
<CENTER>
<TABLE BORDER="3" RULES="ALL" VALIGN="MIDDLE">
<TR>
<TD>
Размерность поля
</TD>
<TD>
Целое без знака
</TD>
<TD>
Целое со знаком
</TD>
</TR>
<TR>
<TD>
байт
</TD>
<TD>
0...255
</TD>
<TD>
–128...+127
</TD>
</TR>
<TR>
<TD>
слово
</TD>
<TD>
0...65 535
</TD>
<TD>
–32 768...+32 767
</TD>
</TR>
<TR>
<TD>
двойное слово
</TD>
<TD>
0...4 294 967 295
</TD>
<TD>
–2 147 483 648...+2 147 483 647
</TD>
</TR>
</TABLE>
</CENTER>
<FONT SIZE="+0">
Как описать числа с фиксированной точкой в программе?
</FONT>
<P>
<FONT SIZE="+0">
Это делается с использованием 
<I>
директив
описания данных
</I>
. К примеру, последовательность описаний двоичных
чисел из сегмента данных листинга 1 (помните о принципе “младший байт по
младшему адресу”) будет выглядеть в памяти так, как показано на рис. 2.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
Листинг 1. Числа с фиксированной точкой
;prg_8_1.asm
masm
model&nbsp;&nbsp; small
stack&nbsp;&nbsp; 256
.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент данных
per_1&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23
per_2&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9856
per_3&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9875645
per_4&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29857
.code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент кода
main:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;точка входа в программу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;связываем регистр dx с сегментом
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax&nbsp;&nbsp; ;данных через регистр ax
exit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;посмотрите в отладчике дамп сегмента данных
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;стандартный выход
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
end&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp; ;конец программы
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<P>
<CENTER>
<IMG SRC="Ris8_02.gif">
<I>
<FONT SIZE="+0">
<B>
Рис. 2.
</B>
 Дамп
памяти для сегмента данных листинга 1
</A>
</FONT>
</I>
</CENTER>
<H3>
<FONT SIZE="+0">
Десятичные числа
</FONT>
</H3>
<FONT SIZE="+0">
<I>
Десятичные числа
</I>
 — специальный вид представления числовой
информации, в основу которого положен принцип кодирования каждой десятичной
цифры числа группой из четырех бит. При этом каждый байт числа содержит
одну или две десятичные цифры в так называемом двоично-десятичном коде
(BCD — Binary-Coded Decimal). Микропроцессор хранит BCD-числа в двух форматах
(рис. 3):
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
упакованном формате — в этом формате каждый байт содержит
две десятичные цифры. Десятичная цифра представляет собой двоичное значение
в диапазоне от 0 до 9 размером 4 бита. При этом код старшей цифры числа
занимает старшие 4 бита. Следовательно, диапазон представления десятичного
упакованного числа в одном байте составляет от 00 до 99;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
неупакованном формате — в этом формате каждый байт содержит
одну десятичную цифру в четырех младших битах. Старшие четыре бита имеют
нулевое значение. Это так называемая зона. Следовательно, диапазон представления
десятичного неупакованного числа в одном байте составляет от 0 до 9.
</FONT>
</LI>
</UL>
<P>
<CENTER>
<IMG SRC="Ris8_03.gif">
<I>
<P>
<FONT SIZE="+0">
<B>
Рис. 3.
</B>
 Представление
BCD-чисел
</A>
</FONT>
</I>
</CENTER>
<P>
<FONT SIZE="+0">
Как описать двоично-десятичные числа в программе?
</FONT>
<P>
<FONT SIZE="+0">
Для этого можно использовать только две директивы описания
и инициализации данных — db и dt. Возможность применения только этих директив
для описания BCD-чисел обусловлена тем, что к таким числам также применим
принцип “младший байт по младшему адресу”, что, как мы увидим далее, очень
удобно для их обработки. И вообще, при использовании такого типа данных
как BCD-числа, порядок описания этих чисел в программе и алгоритм их обработки
— это дело вкуса и личных пристрастий программиста. Это станет ясно после
того, как мы ниже рассмотрим основы работы с BCD-числами. К примеру, приведенная
в сегменте данных листинга 2 последовательность описаний BCD-чисел будет
выглядеть в памяти так, как показано на рис. 4.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
&nbsp;
&nbsp;Листинг 2. BCD-числа
;prg_8_2.asm
masm
model&nbsp;&nbsp; small
stack&nbsp;&nbsp; 256
.data&nbsp;&nbsp; ;сегмент данных
per_1&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,3,4,6,8,2
;неупакованное BCD-число 286432
per_3&nbsp;&nbsp; dt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9875645 ;упакованное BCD-число 9875645
.code&nbsp;&nbsp; ;сегмент кода
main:&nbsp;&nbsp; ;точка входа в программу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;связываем регистр dx с сегментом
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax&nbsp;&nbsp; ;данных через регистр ax
exit:&nbsp;&nbsp; ;посмотрите в отладчике дамп сегмента данных
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;стандартный выход
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
end&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp; ;конец программы
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<P>
<CENTER>
<IMG SRC="Ris8_04.gif">
<P>
<I>
<FONT SIZE="+0">
<B>
Рис. 4.
</B>
 Дамп
памяти для сегмента данных листинга 2
</A>
</FONT>
</I>
</CENTER>
<P>
<FONT SIZE="+0">
После столь подробного обсуждения объектов, с которыми
работают арифметические операции, можно приступить к рассмотрению средств
их обработки на уровне системы команд микропроцессора.
</FONT>
<P>
<A NAME="ДвоичнойАрифметики">
</A>
<HR SIZE="5" WIDTH="60%">
<H2>
<FONT SIZE="+0">
Арифметические операции над целыми двоичными числами
</FONT>
</H2>
<FONT SIZE="+0">
В данном разделе мы рассмотрим особенности каждого из четырех
основных арифметических действий для двоичных чисел со знаком и без знака:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Сложение двоичных чисел без знака">
сложение
двоичных чисел без знака;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Сложение двоичных чисел со знаком">
сложение
двоичных чисел со знаком;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Вычитания">
вычитание двоичных чисел
без знака;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Вычитание двоичных чисел со знаком">
вычитание двоичных чисел со знаком;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Вычитание исложение операндов большой размерности">
вычитание
и сложение операндов большой размерности;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Умножения">
умножение чисел без знака;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Умножение чисел со знаком">
умножение
чисел со знаком;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Деления">
деление чисел без знака;
</A>
</I>
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
<I>
<A HREF="#Деление чисел со знаком">
деление
чисел со знаком.
</A>
</I>
</FONT>
</LI>
</UL>
&nbsp;
<BR>
&nbsp;

<P>
<A NAME="Сложения">
</A>
<A NAME="Сложение двоичных чисел без знака">
</A>
<H3>
<FONT SIZE="+0">
Сложение двоичных чисел без знака
</FONT>
</H3>
<FONT SIZE="+0">
Микропроцессор выполняет сложение операндов по правилам сложения
двоичных чисел. Проблем не возникает до тех пор, пока значение результата
не превышает размерности поля операнда (
<I>
<A HREF="#Таблица_1">
см.
табл. 1
</A>
</I>
). Например, при сложении операндов размером в байт результат
не должен превышать число 255. Если это происходит, то результат оказывается
неверным. Рассмотрим, почему так происходит. К примеру, выполним сложение:
254 + 5 = 259 в двоичном виде. 11111110 + 0000101 = 1 00000011. Результат
вышел за пределы восьми бит и правильное его значение укладывается в 9
бит, а в 8-битовом поле операнда осталось значение 3, что, конечно, неверно.
В микропроцессоре этот исход сложения прогнозируется и предусмотрены специальные
средства для фиксирования подобных ситуаций и их обработки. Так, для фиксирования
ситуации выхода за разрядную сетку результата, как в данном случае, предназначен
флаг переноса cf. Он располагается в бите 0 регистра флагов eflags/flags.
Именно установкой этого флага фиксируется факт переноса единицы из старшего
разряда операнда. Естественно, что программист должен предусматривать возможность
такого исхода операции сложения и средства для корректировки. Это предполагает
включение участков кода после операции сложения, в которых анализируется
флаг cf. Анализ этого флага можно провести различными способами. Самый
простой и доступный — использовать команду условного перехода 
<B>
<I>
<A HREF="../../Text/Command.htm#jcc">
jcc
</A>
</I>
</B>
.
Эта команда в качестве операнда имеет имя метки в текущем сегменте кода.
Переход на эту метку осуществляется в случае, если в результате работы
предыдущей команды флаг cf установился в 1. Если теперь посмотреть на 
<I>
<A HREF="#Рис.1">
рис.
1
</A>
</I>
, то видно, что в системе команд микропроцессора имеются три команды
двоичного сложения:
</FONT>
<UL>
<LI TYPE="CIRCLE">
<FONT SIZE="+0">
<B>
inc операнд
</B>
 — операция инкремента, то есть увеличения
значения операнда на 1;
</FONT>
</LI>
<LI TYPE="CIRCLE">
<FONT SIZE="+0">
<B>
add операнд_1,операнд_2
</B>
 — команда сложения с принципом
действия: операнд_1 = операнд_1 + операнд_2
</FONT>
</LI>
<LI TYPE="CIRCLE">
<FONT SIZE="+0">
<B>
adc операнд_1,операнд_2
</B>
 — команда сложения с учетом
флага переноса cf. Принцип действия команды:
</FONT>
</LI>
<P>
<FONT SIZE="+0">
операнд_1 = операнд_1 + операнд_2 + значение_cf
</FONT>
</UL>
<FONT SIZE="+0">
Обратите внимание на последнюю команду — это команда сложения,
учитывающая перенос единицы из старшего разряда. Механизм появления такой
единицы мы уже рассмотрели. Таким образом, команда adc является средством
микропроцессора для сложения длинных двоичных чисел, размерность которых
превосходит поддерживаемые микропроцессором длины стандартных полей.
</FONT>
<P>
<FONT SIZE="+0">
Рассмотрим пример вычисления суммы чисел (листинг 3).
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE="+0">
В листинге 3 в строках 13–14 создана ситуация, когда результат
сложения выходит за границы операнда. Эта возможность учитывается строкой
15, где команда jnc (хотя можно было обойтись и без нее) проверяет состояние
флага cf. Если он установлен в 1, то это признак того, что результат операции
получился больше по размеру, чем размер операнда, и для его корректировки
необходимо выполнить некоторые действия. В данном случае мы просто полагаем,
что границы операнда расширяются до размера ax, для чего учитываем перенос
в старший разряд командой adc (строка 15). Если у вас остались вопросы,
исследуйте работу команд сложения без учета знака, для чего введите листинг
3, получите исполняемый модуль, запустите отладчик и откройте в нем окна
<TT>
View|Dump
</TT>
 и 
<TT>
View|Registers
</TT>
.&nbsp;
</FONT>
<A NAME="Сложение двоичных чисел со знаком">
</A>
<H3>
<FONT SIZE="+0">
Сложение двоичных чисел со знаком
</FONT>
</H3>
<FONT SIZE="+0">
Теперь настала пора раскрыть небольшой секрет. Дело в том,
что на самом деле микропроцессор не подозревает о различии между числами
со знаком и без знака. Вместо этого у него есть средства фиксирования возникновения
характерных ситуаций, складывающихся в процессе вычислений. Некоторые из
них мы рассмотрели при обсуждении сложения чисел без знака:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
флаг переноса cf, установка которого в 1 говорит о том, что
произошел выход за пределы разрядности операндов;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
команду adc, которая учитывает возможность такого выхода
(перенос из младшего разряда).
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Другое средство — это регистрация состояния старшего (знакового)
разряда операнда, которое осуществляется с помощью флага переполнения of
в регистре eflags (бит 11).
</FONT>
<P>
<FONT SIZE="+0">
Вы, конечно, помните, как представляются числа в компьютере:
положительные — в двоичном коде, отрицательные — в дополнительном коде.
Рассмотрим различные варианты сложения чисел. Примеры призваны показать
поведение двух старших битов операндов и правильность результата операции
сложения.
</FONT>
<H4>
<FONT SIZE="+0">
Пример 1.
</FONT>
</H4>
<PRE>
<FONT SIZE="+0">
&nbsp;30566 = 01110111 01100110
&nbsp;+
&nbsp;00687 = 00000010 10101111
&nbsp;=
&nbsp;31253 = 01111010 00010101
</FONT>
</PRE>
<FONT SIZE="+0">
Следим за переносами из 14-го и 15-го разрядов и правильностью
результата: переносов нет, результат правильный.
</FONT>
<H4>
<FONT SIZE="+0">
Пример 2.
</FONT>
</H4>
<PRE>
<FONT SIZE="+0">
&nbsp;30566 = 01110111 01100110
&nbsp;+
&nbsp;30566 = 01110111 01100110
&nbsp;=
&nbsp;61132 = 11101110 11001100
</FONT>
</PRE>
<FONT SIZE="+0">
Произошел перенос из 14-го разряда; из 15-го разряда переноса
нет. Результат неправильный, так как имеется переполнение — значение числа
получилось больше, чем то, которое может иметь 16-битное число со знаком
(+32 767).
</FONT>
<H4>
<FONT SIZE="+0">
Пример 3.
</FONT>
</H4>
<PRE>
<FONT SIZE="+0">
-30566&nbsp; = 10001000 10011010
&nbsp;+
&nbsp;-04875 = 11101100 11110101
&nbsp;=
&nbsp;-35441 = 01110101 10001111
</FONT>
</PRE>
<FONT SIZE="+0">
Произошел перенос из 15-го разряда, из 14-го разряда нет
переноса. Результат неправильный, так как вместо отрицательного числа получилось
положительное (в старшем бите находится 0).
</FONT>
<H4>
<FONT SIZE="+0">
Пример 4.
</FONT>
</H4>
<PRE>
<FONT SIZE="+0">
&nbsp;-4875 = 11101100 11110101
&nbsp;+
&nbsp;-4875 = 11101100 11110101
&nbsp;=
&nbsp;-9750 = 11011001 11101010
</FONT>
</PRE>
<FONT SIZE="+0">
Есть переносы из 14 и 15-го разрядов. Результат правильный.
</FONT>
<P>
<FONT SIZE="+0">
Таким образом, мы исследовали все случаи и выяснили, что
ситуация переполнения (установка флага of в 1) происходит при переносе:
</FONT>
<UL>
<LI TYPE="DISK">
<FONT SIZE="+0">
из 14-го разряда (для положительных чисел со знаком);
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
из 15-го разряда (для отрицательных чисел).
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
И наоборот, переполнения не происходит (то есть флаг of сбрасывается
в 0), если есть перенос из обоих разрядов или перенос отсутствует в обоих
разрядах.
</FONT>
<P>
<FONT SIZE="+0">
Итак, переполнение регистрируется с помощью флага переполнения
of. Дополнительно к флагу of при переносе из старшего разряда устанавливается
в 1 и флаг переноса cf. Так как микропроцессор не знает о существовании
чисел со знаком и без знака, то вся ответственность за правильность действий
с получившимися числами ложится на программиста. Проанализировать флаги
cf и of можно командами условного перехода jc\jnc и jo\jno соответственно.
</FONT>
<P>
<FONT SIZE="+0">
Что же касается команд сложения чисел со знаком, то они
те же, что и для чисел без знака.&nbsp;
</FONT>
<A NAME="Вычитания">
</A>
<H3>
<FONT SIZE="+0">
Вычитание двоичных чисел без знака
</FONT>
</H3>
<FONT SIZE="+0">
Как и при анализе операции сложения, порассуждаем над сутью
процессов, происходящих при выполнении операции вычитания. Если уменьшаемое
больше вычитаемого, то проблем нет, — разность положительна, результат
верен. Если уменьшаемое меньше вычитаемого, возникает проблема: результат
меньше 0, а это уже число со знаком. В этом случае результат необходимо
завернуть. Что это означает? При обычном вычитании (в столбик) делают заем
1 из старшего разряда. Микропроцессор поступает аналогично, то есть занимает
1 из разряда, следующего за старшим, в разрядной сетке операнда. Поясним
на примере.
</FONT>
<H4>
<FONT SIZE="+0">
Пример 5.
</FONT>
</H4>
<PRE>
<FONT SIZE="+0">
&nbsp; 05 = 00000000 00000101
&nbsp;-10 = 00000000 00001010
&nbsp;Для того чтобы произвести вычитание, произведем
воображаемый заем из старшего разряда:
&nbsp;100000000 00000101
&nbsp;-
&nbsp;00000000 00001010
&nbsp;=
&nbsp;11111111 11111011
</FONT>
</PRE>
<FONT SIZE="+0">
Тем самым по сути выполняется действие
</FONT>
<P>
<FONT SIZE="+0">
(65 536 + 5) — 10 = 65 531,
</FONT>
<P>
<FONT SIZE="+0">
0 здесь как бы эквивалентен числу 65 536. Результат, конечно,
неверен, но микропроцессор считает, что все нормально, хотя факт заема
единицы он фиксирует установкой флага переноса cf. Но посмотрите еще раз
внимательно на результат операции вычитания. Это же –5 в дополнительном
коде! Проведем эксперимент: представим разность в виде суммы 5 + (–10).
</FONT>
<H4>
<FONT SIZE="+0">
Пример 6.
</FONT>
</H4>
<PRE>
<FONT SIZE="+0">
&nbsp;5&nbsp;&nbsp;&nbsp; = 00000000 00000101
&nbsp;+
&nbsp;(-10)= 11111111 11110110
&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1111111111111011
</FONT>
</PRE>
<FONT SIZE="+0">
то есть мы получили тот же результат, что и в предыдущем
примере.
</FONT>
<P>
<FONT SIZE="+0">
Таким образом, после команды вычитания чисел без знака
нужно анализировать состояние флага cf. Если он установлен в 1, то это
говорит о том, что произошел заем из старшего разряда и результат получился
в дополнительном коде.
</FONT>
<P>
<FONT SIZE="+0">
Аналогично командам сложения, группа команд вычитания
состоит из минимально возможного набора. Эти команды выполняют вычитание
по алгоритмам, которые мы сейчас рассматриваем, а учет особых ситуаций
должен производиться самим программистом. К командам вычитания относятся
следующие:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
dec операнд — операция декремента, то есть уменьшения значения
операнда на 1;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
sub операнд_1,операнд_2 — команда вычитания; ее принцип действия:
</FONT>
</LI>
<BR>
<FONT SIZE="+0">
операнд_1 = операнд_1 – операнд_2
</FONT>
<LI>
<FONT SIZE="+0">
sbb операнд_1,операнд_2 — команда вычитания с учетом заема
(флага cf ):
</FONT>
</LI>
<BR>
<FONT SIZE="+0">
операнд_1 = операнд_1 – операнд_2 – значение_cf
</FONT>
</UL>
<FONT SIZE="+0">
Как видите, среди команд вычитания есть команда sbb, учитывающая
флаг переноса cf. Эта команда подобна adc, но теперь уже флаг cf выполняет
роль индикатора заема 1 из старшего разряда при вычитании чисел.
</FONT>
<P>
<FONT SIZE="+0">
Рассмотрим пример (листинг 4) программной обработки ситуации,
разобранной в примере 6.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE="+0">
В этом примере в строке 11 выполняется вычитание. С указанными
для этой команды вычитания исходными данными результат получается в дополнительном
коде (отрицательный). Для того чтобы преобразовать результат к нормальному
виду (получить его модуль), применяется команда neg, с помощью которой
получается дополнение операнда. В нашем случае мы получили дополнение дополнения
или модуль отрицательного результата. А тот факт, что это на самом деле
число отрицательное, отражен в состоянии флага cf. Дальше все зависит от
алгоритма обработки. Исследуйте программу в отладчике.&nbsp;
</FONT>
<A NAME="Вычитание двоичных чисел со знаком">
</A>
<H3>
<FONT SIZE="+0">
Вычитание двоичных чисел со знаком
</FONT>
</H3>
<FONT SIZE="+0">
Здесь все несколько сложнее. Последний пример (листинг 4)
показал то, что микропроцессору незачем иметь два устройства — сложения
и вычитания. Достаточно наличия только одного — устройства сложения. Но
для вычитания способом сложения чисел со знаком в дополнительном коде необходимо
представлять оба операнда — и уменьшаемое, и вычитаемое. Результат тоже
нужно рассматривать как значение в дополнительном коде. Но здесь возникают
сложности. Прежде всего они связаны с тем, что старший бит операнда рассматривается
как знаковый. Рассмотрим пример вычитания 45 – (–127).
</FONT>
<H4>
<NOBR>
<FONT SIZE="+0">
Пример 7.
</FONT>
</NOBR>
</H4>
<FONT SIZE="+0">
<NOBR>
Вычитание чисел со знаком 1
</NOBR>
</FONT>
<PRE>
<FONT SIZE="+0">
&nbsp;&nbsp; 45 = 0010 1101
&nbsp;-
&nbsp;-127 = 1000 0001
&nbsp;=
&nbsp; -44 = 1010 1100
</FONT>
</PRE>
<FONT SIZE="+0">
Судя по знаковому разряду, результат получился отрицательный,
что, в свою очередь, говорит о том, что число нужно рассматривать как дополнение,
равное –44. Правильный результат должен быть равен 172. Здесь мы, как и
в случае знакового сложения, встретились с переполнением мантиссы, когда
значащий разряд числа изменил знаковый разряд операнда. Отследить такую
ситуацию можно по содержимому флага переполнения of. Его установка в 1
говорит о том, что результат вышел за диапазон представления знаковых чисел
(то есть изменился старший бит) для операнда данного размера, и программист
должен предусмотреть действия по корректировке результата.
</FONT>
<P>
<FONT SIZE="+0">
Другой пример разности рассматривается в примере 7, но
выполним мы ее способом сложения.
</FONT>
<H4>
<NOBR>
<FONT SIZE="+0">
Пример 8.
</FONT>
</NOBR>
</H4>
<FONT SIZE="+0">
<NOBR>
Вычитание чисел со знаком 2
</NOBR>
</FONT>
<PRE>
<FONT SIZE="+0">
&nbsp;-45 — 45 = -45 + (-45)= -90.
&nbsp;-45 = 1101 0011
&nbsp;+
&nbsp;-45 = 1101 0011
&nbsp;=
&nbsp;-90 = 1010 0110
</FONT>
</PRE>
<FONT SIZE="+0">
Здесь все нормально, флаг переполнения of сброшен в 0, а
1 в знаковом разряде говорит о том, что значение результата — число в дополнительном
коде.&nbsp;
</FONT>
<A NAME="Вычитание исложение операндов большой размерности">
</A>
<H3>
<FONT SIZE="+0">
Вычитание и сложение операндов большой размерности
</FONT>
</H3>
<FONT SIZE="+0">
Если вы заметили, команды сложения и вычитания работают с
операндами фиксированной размерности: 8, 16, 32 бит. А что делать, если
нужно сложить числа большей размерности, например 48 бит, используя 16-разрядные
операнды? К примеру, сложим два 48-разрядных числа:
</FONT>
<CENTER>
</CENTER>
<P>
<CENTER>
<IMG SRC="Ris8_05.gif">
<FONT SIZE="+0">
</FONT>
</CENTER>
<CENTER>
</CENTER>
<CENTER>
<I>
<FONT SIZE="+0">
<B>
Рис. 5.
</B>
 Сложение операндов большой размерности
</FONT>
</I>
</CENTER>
<P>
<FONT SIZE="+0">
На рис. 5 по шагам показана технология сложения длинных
чисел. Видно, что процесс сложения многобайтных чисел происходит так же,
как и при сложении двух чисел “в столбик”, — с осуществлением, при необходимости,
переноса 1 в старший разряд. Если нам удастся запрограммировать этот процесс,
то мы значительно расширим диапазон двоичных чисел, над которыми мы сможем
выполнять операции сложения и вычитания.
</FONT>
<P>
<FONT SIZE="+0">
Принцип вычитания чисел с диапазоном представления, превышающим
стандартные разрядные сетки операндов, тот же, что и при сложении, то есть
используется флаг переноса cf. Нужно только представлять себе процесс вычитания
в столбик и правильно комбинировать команды микропроцессора с командой
sbb.
</FONT>
<P>
<FONT SIZE="+0">
В завершение обсуждения команд сложения и вычитания отметим,
что кроме флагов cf и of в регистре eflags есть еще несколько флагов, которые
можно использовать с двоичными арифметическими командами. Речь идет о следующих
флагах:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
zf — флаг нуля, который устанавливается в 1, если результат
операции равен 0, и в 1, если результат не равен 0;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
sf — флаг знака, значение которого после арифметических операций
(и не только) совпадает со значением старшего бита результата, то есть
с битом 7, 15 или 31. Таким образом, этот флаг можно использовать для операций
над числами со знаком.
</FONT>
</LI>
</UL>
<A NAME="Умножения">
</A>
<H3>
<FONT SIZE="+0">
Умножение чисел без знака
</FONT>
</H3>
<FONT SIZE="+0">
Для умножения чисел без знака предназначена команда
</FONT>
<P>
<FONT SIZE="+0">
<B>
mul сомножитель_1
</B>
</FONT>
<P>
<FONT SIZE="+0">
Как видите, в команде указан всего лишь один операнд-сомножитель.
Второй операнд — сомножитель_2 задан неявно. Его местоположение фиксировано
и зависит от размера сомножителей. Так как в общем случае результат умножения
больше, чем любой из его сомножителей, то его размер и местоположение должны
быть тоже определены однозначно. Варианты размеров сомножителей и размещения
второго операнда и результата приведены в табл. 2.
</FONT>
<P>
<FONT SIZE="+0">
<B>
Таблица 2.
</B>
 Расположение операндов и результата
при умножении
</FONT>
<CENTER>
<TABLE BORDER="3" RULES="ALL" VALIGN="MIDDLE">
<TR>
<TD>
сомножитель_1
</TD>
<TD>
сомножитель_2
</TD>
<TD ALIGN="CENTER">
Результат
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
Байт
</TD>
<TD ALIGN="CENTER">
al
</TD>
<TD>
16 бит в ax:
<BR>
al — младшая часть результата;
<BR>
ah — старшая часть результата
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
Слово
</TD>
<TD ALIGN="CENTER">
ax
</TD>
<TD>
32 бит в паре dx:ax:
<BR>
ax — младшая часть результата;
<BR>
dx — старшая часть результата
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
Двойное слово
</TD>
<TD ALIGN="CENTER">
eax
</TD>
<TD>
64 бит в паре edx:eax:
<BR>
eax — младшая часть результата;
<BR>
edx — старшая часть результата
</TD>
</TR>
</TABLE>
</CENTER>
&nbsp;

<P>
<FONT SIZE="+0">
Из таблицы видно, что произведение состоит из двух частей
и в зависимости от размера операндов размещается в двух местах — на месте
сомножитель_2 (младшая часть) и в дополнительном регистре ah, dx, edx (старшая
часть). Как же динамически (то есть во время выполнения программы) узнать,
что результат достаточно мал и уместился в одном регистре или что он превысил
размерность регистра и старшая часть оказалась в другом регистре? Для этого
привлекаются уже известные нам по предыдущему обсуждению флаги переноса
cf и переполнения of:
</FONT>
<UL>
<LI>
<FONT SIZE="+0">
если старшая часть результата нулевая, то после операции
произведения флаги cf = 0 и of = 0;
</FONT>
</LI>
<LI>
<FONT SIZE="+0">
если же эти флаги ненулевые, то это означает, что результат
вышел за пределы младшей части произведения и состоит из двух частей, что
и нужно учитывать при дальнейшей работе.
</FONT>
</LI>
</UL>
<FONT SIZE="+0">
Рассмотрим следующий пример программы.
</FONT>
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE="+0">
В этой программе в строке 14 производится умножение значения
в rez_l на число в регистре al. Согласно информации в табл. 2, результат
умножения будет располагаться в регистре al (младшая часть) и регистре
ah (старшая часть). Для выяснения размера результата в строке 15 командой
условного перехода jnc анализируется состояние флага cf и если оно не равно
1, то результат остался в рамках регистра al. Если же cf = 1, то выполняется
команда в строке 16, которая формирует в поле rez_h старшее слово результата.
Команда в строке 18 формирует младшую часть результата. Теперь обратите
внимание на сегмент данных, а именно, на строку 6. В этой строке содержится
директива label. Мы еще не раз будем сталкиваться с этой директивой. В
данном случае она назначает еще одно символическое имя rez адресу, на который
уже указывает другой идентификатор rez_l. Отличие заключается в типах этих
идентификаторов — имя rez имеет тип слова, который ему назначается директивой
label (имя типа указано в качестве операнда label). Введя эту директиву
в программе, мы подготовились к тому, что, возможно, результат операции
умножения будет занимать слово в памяти. Обратите внимание, что мы не нарушили
принципа: младший байт по младшему адресу. Далее, используя имя rez, можно
обращаться к значению в этой области как к слову.&nbsp;
</FONT>
<A NAME="Умножение чисел со знаком">
</A>
<H3>
<FONT SIZE="+0">
Умножение чисел со знаком
</FONT>
</H3>
<FONT SIZE="+0">
Для умножения чисел со знаком предназначена команда
</FONT>
<P>
<FONT SIZE="+0">
<B>
imul операнд_1[,операнд_2,операнд_3]
</B>
</FONT>
<P>
<FONT SIZE="+0">
Эта команда выполняется так же, как и команда mul. Отличительной
особенностью команды imul является только формирование знака.
</FONT>
<BR>
&nbsp;

<P>
<FONT SIZE="+0">
Если результат мал и умещается в одном регистре (то есть
если cf = of = 0), то содержимое другого регистра (старшей части) является
расширением знака — все его биты равны старшему биту (знаковому разряду)
младшей части результата.
</FONT>
<BR>
&nbsp;

<P>
<FONT SIZE="+0">
В противном случае (если cf = of = 1) знаком результата
является знаковый бит старшей части результата, а знаковый бит младшей
части является значащим битом двоичного кода результата.
</FONT>
<BR>
&nbsp;

<P>
<FONT SIZE="+0">
Если вы посмотрите описание команды 
<B>
<I>
<A HREF="../../Text/Command.htm#imul">
imul
</A>
</I>
</B>
,
то увидите, что она допускает более широкие возможности по заданию местоположения
операндов. Это сделано для удобства использования.&nbsp;
</FONT>
<A NAME="Деления">
</A>
<H3>
<FONT SIZE="+0">
Деление чисел без знака
</FONT>
</H3>
<FONT SIZE="+0">
Для деления чисел без знака предназначена команда
</FONT>
<P>
<FONT SIZE="+0">
<B>
div делитель
</B>
</FONT>
<P>
<FONT SIZE="+0">
Делитель может находиться в памяти или в регистре и иметь
размер 8, 16 или 32 бит. Местонахождение делимого фиксировано и так же,
как в команде умножения, зависит от размера операндов. Результатом команды
деления являются значения частного и остатка.
</FONT>
<P>
<FONT SIZE="+0">
Варианты местоположения и размеров операндов операции
деления показаны в табл. 3.
</FONT>
<P>
<B>
<FONT SIZE="+0">
Таблица 3.
</FONT>
</B>
<FONT SIZE="+0">
 Расположение операндов
и результата при делении
</FONT>
<CENTER>
<TABLE BORDER="3" RULES="ALL" VALIGN="MIDDLE">
<TR ALIGN="CENTER">
<TD>
Делимое
</TD>
<TD>
Делитель
</TD>
<TD>
Частное
</TD>
<TD>
Остаток
</TD>
</TR>
<TR ALIGN="CENTER">
<TD ALIGN="CENTER">
16 бит
<BR>
в регистре ax
</TD>
<TD ALIGN="CENTER">
Байт
<BR>
регистр или ячейка памяти
</TD>
<TD>
Байт&nbsp;
<BR>
в регистре al
</TD>
<TD>
Байт&nbsp;
<BR>
в регистре ah
</TD>
</TR>
<TR ALIGN="CENTER">
<TD ALIGN="CENTER">
32 бит
<BR>
dx — старшая часть
<BR>
ax — младшая часть&nbsp;
</TD>
<TD>
Слово 16 бит
<BR>
регистр или ячейка памяти
</TD>
<TD>
Слово 16 бит в&nbsp;
<BR>
регистре ax
</TD>
<TD>
Слово 16 бит в
<BR>
регистре dx
</TD>
</TR>
<TR ALIGN="CENTER">
<TD ALIGN="CENTER">
64 бит
<BR>
edx — старшая часть
<BR>
eax — младшая часть
</TD>
<TD>
Двойное слово 32 бит
<BR>
регистр или ячейка памяти
</TD>
<TD>
Двойное слово
<BR>
32 бит в&nbsp;
<BR>
регистре eax
</TD>
<TD>
Двойное слово
<BR>
32 бит в
<BR>
регистре edx
</TD>
</TR>
</TABLE>
</CENTER>
<P>
После выполнения команды деления содержимое флагов неопределенно, но
возможно возникновение прерывания с номером 0, называемого “деление на
ноль”. Этот вид прерывания относится к так называемым исключениям. Эта
разновидность прерываний возникает внутри микропроцессора из-за некоторых
аномалий во время вычислительного процесса. Прерывание 0, “деление на ноль”,
при выполнении команды div может возникнуть по одной из следующих причин:
<UL>
<LI>
делитель равен нулю;
</LI>
<LI>
частное не входит в отведенную под него разрядную сетку, что может случиться
в следующих случаях:
</LI>
<UL>
<LI>
при делении делимого величиной в слово на делитель величиной в байт, причем
значение делимого в более чем 256 раз больше значения делителя;
</LI>
<LI>
при делении делимого величиной в двойное слово на делитель величиной в
слово, причем значение делимого в более чем 65 536 раз больше значения
делителя;
</LI>
<LI>
при делении делимого величиной в учетверенное слово на делитель величиной
в двойное слово, причем значение делимого в более чем 4 294 967 296 раз
больше значения делителя.
</LI>
</UL>
</UL>
К примеру, выполним деление значения в области del на значение в области
delt (листинг 6).
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<A NAME="Деление чисел со знаком">
</A>
<H3>
<B>
Деление чисел со знаком
</B>
</H3>
Для деления чисел со знаком предназначена команда

<P>
<B>
idiv делитель
</B>
<P>
Для этой команды справедливы все рассмотренные положения, касающиеся
команд и чисел со знаком. Отметим лишь особенности возникновения исключения
0, “деление на ноль”, в случае чисел со знаком. Оно возникает при выполнении
команды idiv по одной из следующих причин:
<UL>
<LI>
делитель равен нулю;
</LI>
<LI>
частное не входит в отведенную для него разрядную сетку.
</LI>
</UL>
Последнее в свою очередь может произойти:
<UL>
<LI>
при делении делимого величиной в слово со знаком на делитель величиной
в байт со знаком, причем значение делимого в более чем 128 раз больше значения
делителя (таким образом, частное не должно находиться вне диапазона от
–128 до +127);
</LI>
<LI>
при делении делимого величиной в двойное слово со знаком на делитель величиной
в слово со знаком, причем значение делимого в более чем 32 768 раз больше
значения делителя (таким образом, частное не должно находиться вне диапазона
от –32 768 до +32 768);
</LI>
<LI>
при делении делимого величиной в учетверенное слово со знаком на делитель
величиной в двойное слово со знаком, причем значение делимого в более чем
2 147 483 648 раз больше значения делителя (таким образом, частное не должно
находиться вне диапазона от –2 147 483 648 до +2 147 483 647).
</LI>
</UL>
<H2>
Вспомогательные команды для целочисленных операций
</H2>
В системе команд микропроцессора есть несколько команд, которые могут облегчить
программирование алгоритмов, производящих арифметические вычисления. В
них могут возникать различные проблемы, для разрешения которых разработчики
микропроцессора предусмотрели несколько команд. Рассмотрим их в следующем
разделе.&nbsp;
<A NAME="ПреобразованияТипов">
</A>
<H3>
Команды преобразования типов
</H3>
Что делать, если размеры операндов, участвующих в арифметических операциях,
разные? Например, предположим, что в операции сложения один операнд является
словом, а другой занимает двойное слово. Выше сказано, что в операции сложения
должны участвовать операнды одного формата. Если числа без знака, то выход
найти просто. В этом случае можно на базе исходного операнда сформировать
новый (формата двойного слова), старшие разряды которого просто заполнить
нулями. Сложнее ситуация для чисел со знаком: как динамически, в ходе выполнения
программы, учесть знак операнда? Для решения подобных проблем в системе
команд микропроцессора есть так называемые команды преобразования типа.
Эти команды расширяют байты в слова, слова — в двойные слова и двойные
слова — в учетверенные слова (64-разрядные значения). Команды преобразования
типа особенно полезны при преобразовании целых со знаком, так как они автоматически
заполняют старшие биты вновь формируемого операнда значениями знакового
бита старого объекта. Эта операция приводит к целым значениям того же знака
и той же величины, что и исходная, но уже в более длинном формате. Подобное
преобразование называется 
<I>
операцией распространения знака
</I>
.

<P>
Существуют два вида команд преобразования типа:
<UL>
<LI>
Команды без операндов — эти команды работают с фиксированными регистрами:
</LI>
</UL>
<UL>
<UL>
<LI TYPE="DISK">
cbw (Convert Byte to Word) — команда преобразования байта (в регистре al)
в слово (в регистре ax) путем распространения значения старшего бита al
на все биты регистра ah;
</LI>
<LI>
cwd (Convert Word to Double) — команда преобразования слова (в регистре
ax) в двойное слово (в регистрах dx:ax) путем распространения значения
старшего бита ax на все биты регистра dx;
</LI>
<LI>
cwde (Convert Word to Double) — команда преобразования слова (в регистре
ax) в двойное слово (в регистре eax) путем распространения значения старшего
бита ax на все биты старшей половины регистра eax;
</LI>
<LI>
cdq (Convert Double Word to Quarter Word) — команда преобразования двойного
слова (в регистре eax) в учетверенное слово (в регистрах edx:eax) путем
распространения значения старшего бита eax на все биты регистра edx.
</LI>
</UL>
</UL>
<UL>
<LI>
Команды movsx и movzx, относящиеся к командам обработки строк (см. урок
11). Эти команды обладают полезным свойством в контексте нашей проблемы:
</LI>
&nbsp;

<UL>
<LI TYPE="DISK">
movsx операнд_1,операнд_2 — переслать с распространением знака. Расширяет
8 или 16-разрядное значение операнд_2, которое может быть регистром или
операндом в памяти, до 16 или 32-разрядного значения в одном из регистров,
используя значение знакового бита для заполнения старших позиций операнд_1.
Данную команду удобно использовать для подготовки операндов со знаками
к выполнению арифметических действий;
</LI>
<LI>
movzx операнд_1,операнд_2 — переслать с расширением нулем. Расширяет 8
или 16-разрядное значение операнд_2 до 16 или 32-разрядного с очисткой
(заполнением) нулями старших позиций операнд_2. Данную команду удобно использовать
для подготовки операндов без знака к выполнению арифметических действий.
</LI>
</UL>
</UL>
<P>
К примеру, вычислим значение y = (a + b)/c, где a, b, c — байтовые знаковые
переменные (листинг 7).
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
В этой программе делимое для команды idiv (строка 17) готовится заранее.
Так как делитель имеет размер байта, то делимое должно быть словом. С учетом
этого сложение осуществляется параллельно с преобразованием размера результата
в слово (строки 13–16). Для примера расширение операндов со знаком производится
двумя разными командами — cbw и movsx.&nbsp;
<A NAME="Другие полезные команды">
</A>
<H3>
Другие полезные команды
</H3>
<B>
xadd назначение,источник
</B>
 — обмен местами и сложение.

<P>
Команда позволяет выполнить последовательно два действия:
<UL>
<LI>
обменять значения назначение и источник;
</LI>
<LI>
поместить на место операнда назначение сумму:
</LI>
<BR>
назначение = назначение + источник.
</UL>
<A NAME="ИзмененияЗнака">
</A>
<P>
<B>
neg операнд
</B>
 — отрицание с дополнением до двух.

<P>
Команда выполняет инвертирование значения операнд. Физически команда
выполняет одно действие:
<BR>
операнд = 0 – операнд, то есть вычитает операнд из нуля.
<BR>
Команду neg операнд можно применять:
<UL>
<LI>
для смены знака;
</LI>
<LI>
для выполнения вычитания из константы.
</LI>
</UL>
Дело в том, что команды sub и sbb не позволяют вычесть что-либо из константы,
так как константа не может служить операндом-приемником в этих операциях.
Поэтому данную операцию можно выполнить с помощью двух команд:
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
neg ax ;смена знака (ax)
...
add ax,340 ;фактически вычитание: (ax)=340-(ax)
&nbsp;
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
<A NAME="ДесятичнойАрифметики">
</A>
<H1>
Арифметические операции над двоично-десятичными числами
</H1>
В данном разделе мы рассмотрим особенности каждого из четырех основных
арифметических действия для упакованных и неупакованных двоично-десятичных
чисел:
<UL>
<LI>
<I>
<A HREF="#КоррекцияСложения">
сложение неупакованных BCD-чисел;
</A>
</I>
</LI>
<LI>
<I>
<A HREF="#КоррекцияВычитания">
вычитание неупакованных BCD-чисел;
</A>
</I>
</LI>
<LI>
<I>
<A HREF="#КоррекцияДляУмножения">
умножение неупакованных
BCD-чисел;
</A>
</I>
</LI>
<LI>
<I>
<A HREF="#КоррекцияДляДеления">
деление неупакованных BCD-чисел;
</A>
</I>
</LI>
<LI>
<I>
<A HREF="#Сложение упакованных BCD-чисел">
сложение упакованных
BCD-чисел;
</A>
</I>
</LI>
<LI>
<I>
<A HREF="#Вычитание упакованных BCD-чисел">
вычитание упакованных
BCD-чисел.
</A>
</I>
</LI>
</UL>
&nbsp;
<BR>
&nbsp;

<P>
У вас справедливо может возникнуть вопрос: а зачем нужны BCD-числа?
Ответ может быть следующим: BCD-числа нужны в деловых приложениях, то есть
там, где числа должны быть большими и точными. Как мы уже убедились на
примере двоичных чисел, операции с такими числами довольно проблематичны
для языка ассемблера. К недостаткам использования двоичных чисел можно
отнести следующие:
<UL>
<LI>
значения величин в формате слова и двойного слова имеют ограниченный диапазон.
Если программа предназначена для работы в области финансов, то ограничение
суммы в рублях величиной 65 536 (для слова) или даже 4 294 967 296 (для
двойного слова) будет существенно сужать сферу ее применения (да еще в
наших экономических условиях — тут уж никакая деноминация не поможет);
</LI>
<LI>
наличие ошибок округления. Представляете себе программу, работающую где-нибудь
в банке, которая не учитывает величину остатка при действиях с целыми двоичными
числами и оперирует при этом миллиардами? Не хотелось бы быть автором такой
программы. Применение чисел с плавающей точкой не спасет — там существует
та же проблема округления;
</LI>
<LI>
представление большого объема результатов в символьном виде (ASCII-коде).
Деловые программы не просто выполняют вычисления; одной из целей их использования
является оперативная выдача информации пользователю. Для этого, естественно,
информация должна быть представлена в символьном виде. Перевод чисел из
двоичного кода в ASCII- код, как мы уже видели, требует определенных вычислительных
затрат. Число с плавающей точкой еще труднее перевести в символьный вид.
А вот если посмотреть на шестнадцатеричное представление неупакованной
десятичной цифры (в начале нашего занятия) и на соответствующий ей символ
в таблице ASCII, то видно что они отличаются на величину 30h. Таким образом,
преобразование в символьный вид и обратно получается намного проще и быстрее.
</LI>
</UL>
Наверняка, вы уже убедились в важности овладения хотя бы основами действий
с десятичными числами. Далее рассмотрим особенности выполнения основных
арифметических операций с десятичными числами. Для предупреждения возможных
вопросов отметим сразу тот факт, что отдельных команд сложения, вычитания,
умножения и деления BCD-чисел нет. Сделано это по вполне понятным причинам:
размерность таких чисел может быть сколь угодно большой. Складывать и вычитать
можно двоично-десятичные числа как в упакованном формате, так и в неупакованном,
а вот делить и умножать можно только неупакованные BCD-числа. Почему это
так, будет видно из дальнейшего обсуждения.
<H2>
Арифметические действия над неупакованными BCD-числами
</H2>
<A NAME="КоррекцияСложения">
</A>
<H3>
Сложение неупакованных BCD-чисел
</H3>
Рассмотрим два случая сложения.
<H4>
<NOBR>
Пример 9.
</NOBR>
</H4>
<NOBR>
Результат сложения не больше 9
</NOBR>
<PRE>
&nbsp;6 = 0000 0110
&nbsp;+
&nbsp;3 = 0000 0011
&nbsp;=
&nbsp;9 = 0000 1001
</PRE>
Переноса из младшей тетрады в старшую нет. Результат правильный.
<H4>
<NOBR>
Пример 10.
</NOBR>
</H4>
<NOBR>
Результат сложения больше 9
</NOBR>
<PRE>
&nbsp;06 = 0000 0110
&nbsp;+
&nbsp;07 = 0000 0111
&nbsp;=
&nbsp;13 = 0000 1101
</PRE>
То есть мы получили уже не BCD-число. Результат неправильный. Правильный
результат в неупакованном BCD-формате должен быть таким:
<BR>
0000 0001 0000 0011 в двоичном представлении (или 13 в десятичном).

<P>
Проанализировав данную проблему при сложении BCD-чисел (и подобные проблемы
при выполнении других арифметических действий) и возможные пути ее решения,
разработчики системы команд микропроцессора решили не вводить специальные
команды для работы с BCD-числами, а ввести несколько корректировочных команд.

<P>
Назначение этих команд — в корректировке результата работы обычных арифметических
команд для случаев когда операнды в них являются BCD-числами.

<P>
В случае вычитания в примере 10 видно, что полученный результат нужно
корректировать. Для коррекции операции сложения двух однозначных неупакованных
BCD-чисел в системе команд микропроцессора существует специальная команда

<P>
<B>
aaa (ASCII Adjust for Addition)
</B>
 — коррекция результата сложения
для представления в символьном виде.

<P>
Эта команда не имеет операндов. Она работает неявно только с регистром
al и анализирует значение его младшей тетрады:
<UL>
<LI>
если это значение меньше 9, то флаг cf сбрасывается в 0 и осуществляется
переход к следующей команде;
</LI>
<LI>
если это значение больше 9, то выполняются следующие действия:
</LI>
<UL>
<LI TYPE="SQUARE">
к содержимому младшей тетрады al (но не к содержимому всего регистра!)
прибавляется 6, тем самым значение десятичного результата корректируется
в правильную сторону;
</LI>
<LI TYPE="SQUARE">
флаг cf устанавливается в 1, тем самым фиксируется перенос в старший разряд,
для того чтобы его можно было учесть в последующих действиях.
</LI>
</UL>
</UL>
Так, в примере 10, предполагая, что значение суммы 0000 1101 находится
в al, после команды aaa в регистре будет 1101 + 0110= 0011, то есть двоичное
0000 0011 или десятичное 3, а флаг cf установится в 1, то есть перенос
запомнился в микропроцессоре. Далее программисту нужно будет использовать
команду сложения adc, которая учтет перенос из предыдущего разряда. Приведем
пример программы сложения двух неупакованных BCD-чисел.
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
В листинге 8 есть несколько интересных моментов, над которыми есть смысл
поразмыслить. Начнем с описания BCD-чисел. Из строк 5 и 6 видно, что порядок
их ввода обратен нормальному, то есть цифры младших разрядов расположены
по меньшему адресу. Но это вполне логично по нескольким причинам:
<UL>
<LI>
во-первых, такой порядок удовлетворяет общему принципу представления данных
для микропроцессоров Intel;
</LI>
<LI>
во-вторых, это очень удобно для поразрядной обработки неупакованных BCD-чисел,
так как каждое из них занимает один байт.
</LI>
</UL>
Хотя, как уже было отмечено, программист сам волен выбирать способ описания
BCD-чисел в сегменте данных. Строки 14–15 содержат команды, которые складывают
цифры в очередных разрядах BCD-чисел, при этом учитывается возможный перенос
из младшего разряда. Команда aaa в строке 16 корректирует результат сложения,
формируя в al BCD-цифру и, при необходимости, устанавливая в 1 флаг cf.
Строка 20 учитывает возможность переноса при сложении цифр из самых старших
разрядов чисел. Результат сложения формируется в поле sum, описанном в
строке 7.&nbsp;
<A NAME="КоррекцияВычитания">
</A>
<H3>
Вычитание неупакованных BCD-чисел
</H3>
Ситуация здесь вполне аналогична сложению. Рассмотрим те же случаи.
<H4>
<NOBR>
Пример 11.
</NOBR>
</H4>
<NOBR>
Результат вычитания не больше 9
</NOBR>
<PRE>
&nbsp;6 = 0000 0110
&nbsp;-
&nbsp;3 = 0000 0011
&nbsp;=
&nbsp;3 = 0000 0011
</PRE>
Как видим, заема из старшей тетрады нет. Результат верный и корректировки
не требует.
<H4>
<NOBR>
Пример 12.
</NOBR>
</H4>
<NOBR>
Результат вычитания больше 9
</NOBR>
<PRE>
&nbsp; 6 = 0000 0110
&nbsp;-
&nbsp; 7 = 0000 0111
&nbsp;=
&nbsp;-1 = 1111 1111
</PRE>
Вычитание проводится по правилам двоичной арифметики. Поэтому результат
не является BCD-числом.
<BR>
Правильный результат в неупакованном BCD-формате должен быть 9 (0000
1001 в двоичной системе счисления). При этом предполагается заем из старшего
разряда, как при обычной команде вычитания, то есть в случае с BCD числами
фактически должно быть выполнено вычитание 16 – 7. Таким образом видно,
что, как и в случае сложения, результат вычитания нужно корректировать.
Для этого существует специальная команда:

<P>
<B>
aas (ASCII Adjust for Substraction)
</B>
 — коррекция результата вычитания
для представления в символьном виде.

<P>
Команда aas также не имеет операндов и работает с регистром al, анализируя
его младшую тетраду следующим образом:
<UL>
<LI>
если ее значение меньше 9, то флаг cf сбрасывается в 0 и управление передается
следующей команде;
</LI>
<LI>
если значение тетрады в al больше 9, то команда aas выполняет следующие
действия:
</LI>
<OL>
<LI>
из содержимого младшей тетрады регистра al (заметьте — не из содержимого
всего регистра) вычитает 6;
</LI>
<LI>
обнуляет старшую тетраду регистра al;
</LI>
<LI>
устанавливает флаг cf в 1, тем самым фиксируя воображаемый заем из старшего
разряда.
</LI>
</OL>
</UL>
Понятно, что команда aas применяется вместе с основными командами вычитания
sub и sbb. При этом команду sub есть смысл использовать только один раз,
при вычитании самых младших цифр операндов, далее должна применяться команда
sbb, которая будет учитывать возможный заем из старшего разряда. В листинге
9 мы обходимся одной командой sbb, которая в цикле производит поразрядное
вычитание двух BCD-чисел.
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
Данная программа не требует особых пояснений, когда уменьшаемое больше
вычитаемого. Поэтому обратите внимание на строку 24. С ее помощью мы предусматриваем
случай, когда после вычитания старших цифр чисел был зафиксирован факт
заема. Это говорит о том, что вычитаемое было больше уменьшаемого, в результате
чего разность будет неправильной. Эту ситуацию нужно как-то обработать.
С этой целью в строке 24 командой jc анализируется флаг cf. По результату
этого анализа мы уходим на ветку программы, обозначенную меткой m2, где
и будут выполняться некоторые действия.&nbsp;
<A NAME="КоррекцияДляУмножения">
</A>
<H3>
Умножение неупакованных BCD-чисел
</H3>
На примере сложения и вычитания неупакованных чисел стало понятно, что
стандартных алгоритмов для выполнения этих действий над BCD-числами нет
и программист должен сам, исходя из требований к своей программе, реализовать
эти операции.
<BR>
Реализация двух оставшихся операций — умножения и деления — еще более
сложна. В системе команд микропроцессора присутствуют только средства для
производства умножения и деления одноразрядных неупакованных BCD-чисел.

<P>
Для того чтобы умножать числа произвольной размерности, нужно реализовать
процесс умножения самостоятельно, взяв за основу некоторый алгоритм умножения,
например “в столбик”.

<P>
Для того чтобы перемножить два одноразрядных BCD-числа, необходимо:
<UL>
<LI>
поместить один из сомножителей в регистр al (как того требует команда mul);
</LI>
<LI>
поместить второй операнд в регистр или память, отведя байт;
</LI>
<LI>
перемножить сомножители командой mul (результат, как и положено, будет
в ax);
</LI>
<LI>
результат, конечно, получится в двоичном коде, поэтому его нужно скорректировать.
</LI>
</UL>
Для коррекции результата после умножения применяется специальная команда

<P>
<B>
aam (ASCII Adjust for Multiplication)
</B>
 — коррекция результата
умножения для представления в символьном виде.

<P>
Она не имеет операндов и работает с регистром ax следующим образом:
<UL>
<LI>
делит al на 10;
</LI>
<LI>
результат деления записывается так: частное в al, остаток в ah.
</LI>
</UL>
В результате после выполнения команды aam в регистрах al и ah находятся
правильные двоично-десятичные цифры произведения двух цифр.

<P>
В листинге 10 приведен пример умножения BCD-числа произвольной размерности
на однозначное BCD-число.
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
Данную программу можно легко модифицировать для умножения BCD-чисел произвольной
длины. Для этого достаточно представить алгоритм умножения “в столбик”.
Листинг 10 можно использовать для получения частичных произведений в этом
алгоритме. После их сложения со сдвигом получиться искомый результат.

<P>
Перед окончанием обсуждения команды aam необходимо отметить еще один
вариант ее применения. Эту команду можно применять для преобразования двоичного
числа в регистре al в неупакованное BCD-число, которое будет размещено
в регистре ax: старшая цифра результата в ah, младшая — в al. Понятно,
что двоичное число должно быть в диапазоне 0...99.&nbsp;
<A NAME="КоррекцияДляДеления">
</A>
<H3>
Деление неупакованных BCD-чисел
</H3>
Процесс выполнения операции деления двух неупакованных BCD-чисел несколько
отличается от других, рассмотренных ранее, операций с ними. Здесь также
требуются действия по коррекции, но они должны выполняться до основной
операции, выполняющей непосредственно деление одного BCD-числа на другое
BCD-число. Предварительно в регистре ax нужно получить две неупакованные
BCD-цифры делимого. Это делает программист удобным для него способом. Далее
нужно выдать команду aad:

<P>
<B>
aad (ASCII Adjust for Division)
</B>
 — коррекция деления для представления
в символьном виде.

<P>
Команда не имеет операндов и преобразует двузначное неупакованное BCD-число
в регистре ax в двоичное число. Это двоичное число впоследствии будет играть
роль делимого в операции деления. Кроме преобразования, команда aad помещает
полученное двоичное число в регистр al. Делимое, естественно, будет двоичным
числом из диапазона 0...99.
<BR>
Алгоритм, по которому команда aad осуществляет это преобразование,
состоит в следующем:
<UL>
<LI>
умножить старшую цифру исходного BCD-числа в ax (содержимое ah) на 10;
</LI>
<LI>
выполнить сложение ah + al, результат которого (двоичное число) занести
в al;
</LI>
<LI>
обнулить содержимое ah.
</LI>
</UL>
Далее программисту нужно выдать обычную команду деления div для выполнения
деления содержимого ax на одну BCD-цифру, находящуюся в байтовом регистре
или байтовой ячейке памяти.

<P>
Деление неупакованных BCD-чисел иллюстрируется листингом 11.
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
Аналогично aam, команде aad можно найти и другое применение — использовать
ее для перевода неупакованных BCD-чисел из диапазона 0...99 в их двоичный
эквивалент.

<P>
Для деления чисел большей разрядности, так же как и в случае умножения,
нужно реализовывать свой алгоритм, например “в столбик”, либо найти более
оптимальный путь.&nbsp;
<A NAME="Сложение упакованных BCD-чисел">
</A>
<H2>
Арифметические действия над упакованными BCD-числами
</H2>
Как уже отмечалось выше, упакованные BCD-числа можно только складывать
и вычитать. Для выполнения других действий над ними их нужно дополнительно
преобразовывать либо в неупакованный формат, либо в двоичное представление.
Из-за того, что упакованные BCD-числа представляют не слишком большой интерес,
мы их рассмотрим кратко.
<H3>
Сложение упакованных BCD-чисел
</H3>
Вначале разберемся с сутью проблемы и попытаемся сложить два двузначных
упакованных BCD-числа.
<H4>
<NOBR>
Пример 13.
</NOBR>
</H4>
<NOBR>
Сложение упакованных BCD-чисел
</NOBR>
<PRE>
&nbsp;67&nbsp; = 0110 0111
&nbsp;+
&nbsp;75&nbsp; = 0111 0101
&nbsp;=
&nbsp;142 = 1101 1100 = 220
</PRE>
Как видим, в двоичном виде результат равен 1101 1100 (или 220 в десятичном
представлении), что неверно. Это происходит по той причине, что микропроцессор
не подозревает о существовании BCD-чисел и складывает их по правилам сложения
двоичных чисел. На самом деле, результат в двоично-десятичном виде должен
быть равен 0001 0100 0010 (или 142 в десятичном представлении).

<P>
Видно, что как и для неупакованных BCD-чисел, для упакованных BCD-чисел
существует потребность как-то корректировать результаты арифметических
операций.
<BR>
Микропроцессор предоставляет для этого команду daa:

<P>
<B>
daa (Decimal Adjust for Addition)
</B>
 — коррекция результата сложения
для представления в десятичном виде.
<BR>
Команда daa преобразует содержимое регистра al в две упакованные десятичные
цифры по алгоритму, приведенному в описании команды 
<B>
<I>
<A HREF="../../Text/Command.htm#daa">
daa
</A>
</I>
</B>
.
<BR>
Получившаяся в результате сложения единица (если результат сложения
больше 99) запоминается в флаге cf, тем самым учитывается перенос в старший
разряд.

<P>
Проиллюстрируем сказанное на примере сложения двух двузначных BCD-чисел
в упакованном формате (листинг 12).
<TABLE BORDER="5" CELLPADDING="2" COLS="1">
<TR>
<TD>
<PRE>
<TT>
<FONT>
</FONT>
</TT>
</PRE>
</TD>
</TR>
</TABLE>
В приведенном примере все достаточно прозрачно, единственное, на что следует
обратить внимание, — это описание упакованных BCD-чисел и порядок формирования
результата. Результат формируется в соответствии с основным принципом работы
микропроцессоров Intel: младший байт по младшему адресу.&nbsp;
<A NAME="Вычитание упакованных BCD-чисел">
</A>
<H3>
Вычитание упакованных BCD-чисел
</H3>
Аналогично сложению, микропроцессор рассматривает упакованные BCD-числа
как двоичные и, соответственно, выполняет вычитание BCD-чисел как двоичных.
<H4>
<NOBR>
Пример 14.
</NOBR>
</H4>
<NOBR>
Вычитание упакованных BCD-чисел
</NOBR>
<PRE>
Выполним вычитание 67-75. Так как микропроцессор
выполняет вычитание способом сложения, то и мы последуем
этому:
&nbsp;67 = 0110 0111
&nbsp;+
&nbsp;-75 = 1011 0101
&nbsp;=
&nbsp; -8 = 0001 1100 = 28 ???
</PRE>
Как видим, результат равен 28 в десятичной системе счисления, что является
абсурдом. В двоично-десятичном коде результат должен быть равен 0000 1000
(или 8 в десятичной системе счисления).

<P>
При программировании вычитания упакованных BCD-чисел программист, как
и при вычитании неупакованных BCD-чисел, должен сам осуществлять контроль
за знаком. Это делается с помощью флага cf, который фиксирует заем из старших
разрядов.
<BR>
Само вычитание BCD-чисел осуществляется простой командой вычитания
sub или sbb. Коррекция результата осуществляется командой das:

<P>
<B>
das (Decimal Adjust for Substraction)
</B>
 — коррекция результата
вычитания для представления в десятичном виде.
<BR>
Команда das преобразует содержимое регистра al в две упакованные десятичные
цифры по алгоритму, приведенному в описании команды 
<B>
<I>
<A HREF="../../Text/Command.htm#das">
das
</A>
</I>
</B>
.&nbsp;
<HR SIZE="5" WIDTH="80%">
</BODY>
</HTML>
